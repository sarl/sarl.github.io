<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<title>Skill Reference</title>
<meta name="description" content="">
<meta name="author" content="Jnario">
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link rel="stylesheet" href="../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../css/custom.css">
<link rel="stylesheet" href="../../../../css/prettify.css">
<script type="text/javascript" src="../../../../js/prettify.js"></script><script type="text/javascript" src="../../../../js/lang-jnario.js"></script><script type="text/javascript" src="../../../../js/jquery.js"></script><script type="text/javascript" src="../../../../js/bootstrap-tab.js"></script>
</head>
<body onload="prettyPrint()">
<!-- Fixed navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">SARL</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="active"><a href="/">Home</a></li>
        <li><a href="/docs">Documentation</a></li>
        <li><a href="/download">Download</a></li>
        <li><a href="/news">News &amp; Events</a></li>
        <li><a href="/about">About</a></li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
</div>
	<div class="container">
		<div class="tabbable">
			<div class="content">
				<div class="page-header pending">
					<h1>Skill Reference</h1>
					  <ul class="nav nav-tabs pull-right">
<li class="active"><a href="#spec" data-toggle="tab">Spec</a></li>
						<li><a href="#source" data-toggle="tab">Source</a></li>
					  </ul>
</div>
				<div class="row">
					<div class="span12">
						  <div class="tab-content">
							  	<div class="tab-pane active" id="spec">
<p>This document describes how to define skills in SARL. Before reading this document, it is recommended to read the <a href="./GeneralSyntaxReferenceSpec.html">General Syntax Reference</a>, and the <a href="./CapacityReferenceSpec.html">Capacity Reference</a>.</p>
<p>A <em>Capacity</em> is the specification of a collection of actions. This specification makes no assumptions about its implementation. It could be used to specify what an agent can do, what a behavior requires for its execution.</p>
<p>A <em>Skill</em> is a possible implementation of a capacity fulfilling all the constraints of this specification.</p>
<h3 class="exampleGroup passed" id="Defining_a_Skill">Defining a Skill</h3>
<ul>
<li>
<p id="Basic_Definition" class="example passed"><strong>Basic Definition</strong></p>
<p>The definition of a skill is done with the <code>skill</code> keyword. A skill must always implement a capacity. This relationship is specified with the <code>implements</code> keyword.</p>
<p>Below, a skill is defined for outputing the messages on the standard console. Note that all the actions defined in the implemented capacity must have a definition (with a body) in the skill.</p>
<pre class="prettyprint lang-spec linenums">
skill ConsoleLogging implements Logging {
  def info(text : String) {
    System.out.println(text)
  }
  def debug(text : String) {
    System.err.println(text)
  }
}</pre>
</li>
<li>
<p id="Field_Definition" class="example passed"><strong>Field Definition</strong></p>
<p>In several cases, it is useful or mandatory to base the capacity's implementation on attributes (fields).</p>
<p>The following example defines a skill that uses the standard Java logging system. For avoiding to create an instance of the Java logger each time the capacity's actions are invoked, an instance of the Java logger is created and stored into a field of the skill.</p>
<pre class="prettyprint lang-spec linenums">
skill StandardJavaLogging implements Logging {
  // A field is defined in the skill
  val logger = Logger.anonymousLogger
  def info(text : String) {
    logger.info(text)
  }
  def debug(text : String) {
    logger.fine(text)
  }
}</pre>
</li>
<li>
<p id="Action_Definition" class="example passed"><strong>Action Definition</strong></p>
<p>As for fields, it is possible to declare additional methods in the skill.</p>
<pre class="prettyprint lang-spec linenums">
skill MyLogging implements Logging {
  def info(text : String) {
    output(text)
  }
  def debug(text : String) {
    output(text)
  }
  // Define an utility function
  // that is outputing the text
  def output(t : String) {
    System.err.println(t)
  }
}</pre>
</li>
<li>
<p id="Constructor_Definition" class="example passed"><strong>Constructor Definition</strong></p>
<p>By default, it is not needed to specify a constructor for the skills. However, the definition of a constructor is mandatory if a value must be initialized.</p>
<p>The constructors of the <code>Skill</code> class are: </p>
<ul>
<li>The default constructor: <code>def Skill()</code>
</li> <li>The constructor with owner: <code>def Skill(owner : Agent)</code>
</li> </ul>
<pre class="prettyprint lang-spec linenums">
skill StandardJavaLogging implements Logging {
  // A field is defined in the skill
  val logger : Logger
  // The constructor is mandatory
  // for defining the field "logger"
  new (l : Logger) {
    super() // Call the super's constructor
    logger = l
  }
  
  def info(text : String) {
    logger.info(text)
  }
  def debug(text : String) {
    logger.fine(text)
  }
}</pre>
</li>
<li>
<p id="Multiple_Capacity_Implementation" class="example passed"><strong>Multiple Capacity Implementation</strong></p>
<p>In some use cases, it is useful to define a skill by implementing more than one capacity. Below, the <code>MyLogging</code> skill is defined as an implementation of the capacities <code>Logging</code> and <code>LogReader</code>. All the methods defined in the implemented interfaces must have an implementation in the skill.</p>
<p>If two implemented capacities has the same action signature, it must be implemented only once time in the skill.</p>
<pre class="prettyprint lang-spec linenums">
capacity LogReader {
  def open(filename : String) : int
  def info(t : String)
  def close(fid : int)
}
skill MyLogging implements Logging, LogReader {
  // Shared implementation for the methods
  // defind in the two capacities.
  def info(text : String) {
    System.out.println(text)
  }
  def debug(text : String) {
    System.out.println(text)
  }
  def open(filename : String) : int {
    return 0
  }
  def close(fid : int) {
  }
}</pre>
</li>
<li>
<p id="Extending_a_Skill" class="example passed"><strong>Extending a Skill</strong></p>
<p>In some use cases, it is useful to specialize the definition of a skill. This mechanism is supported by the inheritance feature of SARL, which has the same semantic as the inheritance mechanism as the Java object-oriented language.</p>
<p>The extended skill is specified just after the <code>extends</code> keyword.</p>
<p><span class="label label-warning">Important</span> A skill can extend only one other skill type (same constrain as for the classes in the Java language).</p>
<p>In the following code, the <code>StandardJavaLogging</code> skill (defined previously) is extended for changing the output of the info.</p>
<p><span class="label label-warning">Important</span> A skill must implement a capacity, even if it is extending an existing skill. It means that the <code>implements</code> must be given, even if the extended skill is already implementing the capacity.</p>
<pre class="prettyprint lang-spec linenums">
skill ExtendedLogging extends StandardJavaLogging implements Logging {
  def info(text : String) {
    super.info("INFO: "+text)
  }
}</pre>
</li>
</ul>
<h3 class="exampleGroup pending" id="Builtin_Skills">Builtin Skills</h3>
<p>Several capacities are defined and reserved by the SARL Core Specification. The corresponding skills are provided by the runtime environment (such as the <a href="http://www.janusproject.io">Janus platform</a>). The builtin skills are described in the <a href="./BuiltinCapacityReferenceSpec.html">Builtin Capacity Reference</a>.</p>
<h3 class="exampleGroup pending" id="Use_of_the_Skills">Use of the Skills</h3>
<p>Details on the use of the skills may be found in the references of the major behavior-based concepts of SARL:</p>
<ul>
<li><a href="AgentReferenceSpec.html">Agent</a></li> <li><a href="BehaviorReferenceSpec.html">Behavior</a></li> </ul>
</div>
						    <div class="tab-pane" id="source">
						    	<h3>Skill.spec</h3>
						    	<p>
</p>
<pre class="prettyprint lang-spec linenums">
/*
 * Copyright 2014 Sebastian RODRIGUEZ, Nicolas GAUD, St√©phane GALLAND
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.docs.reference

import com.google.inject.Inject
import io.sarl.docs.utils.SARLParser
import io.sarl.docs.utils.SARLSpecCreator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.jnario.runner.CreateWith

/**
 * This document describes how to define skills in SARL.
 * Before reading this document, it is recommended to read
 * the [General Syntax Reference](./GeneralSyntaxReferenceSpec.html),
 * and the [Capacity Reference](./CapacityReferenceSpec.html).
 * 
 * A *Capacity* is the specification of a collection of actions. This specification 
 * makes no assumptions about its implementation. It could be used to specify 
 * what an agent can do, what a behavior requires for its execution.
 * 
 * A *Skill* is a possible implementation of a capacity fulfilling all the 
 * constraints of this specification.
 */
@CreateWith(SARLSpecCreator)
describe "Skill Reference" {

    @Inject extension SARLParser
    @Inject extension IQualifiedNameProvider

    describe "Defining a Skill" {
      
      /* The definition of a skill is done with the &lt;code&gt;skill&lt;/code&gt;
       * keyword. A skill must always implement a capacity. This
       * relationship is specified with the &lt;code&gt;implements&lt;/code&gt; keyword.
       * 
       * Below, a skill is defined for outputing the messages on the standard console.
       * Note that all the actions defined in the implemented capacity must
       * have a definition (with a body) in the skill.
       *  
       * @filter(.* = '''|'''|.parsesSuccessfully.*) 
       */
      fact "Basic Definition"{
        val model = '''
        skill ConsoleLogging implements Logging {
          def info(text : String) {
            System.out.println(text)
          }
          def debug(text : String) {
            System.err.println(text)
          }
        }
        '''.parsesSuccessfully(
          "package io.sarl.docs.reference.sr
          capacity Logging {
            // Log an information message
            def info(text : String)
            // Log a debugging message
            def debug(text : String)
          }",
          // TEXT
          ""
        )
        model.mustHavePackage("io.sarl.docs.reference.sr")
        model.mustNotHaveImport
        model.mustHaveTopElements(2)
        var c = model.elements.get(0).mustBeCapacity("Logging").mustHaveFeatures(2)
        c.features.get(0).mustBeActionSignature("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        c.features.get(1).mustBeActionSignature("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        var s = model.elements.get(1).mustBeSkill("ConsoleLogging", null, "io.sarl.docs.reference.sr.Logging").mustHaveFeatures(2)
        s.features.get(0).mustBeAction("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s.features.get(1).mustBeAction("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
      }
    
      /* In several cases, it is useful or mandatory to base the
       * capacity's implementation on attributes (fields).
       * 
       * The following example defines a skill that uses the standard
       * Java logging system.
       * For avoiding to create an instance of the Java logger each
       * time the capacity's actions are invoked, an instance
       * of the Java logger is created and stored into a field
       * of the skill.
       *  
       * @filter(.* = '''|'''|.parsesSuccessfully.*) 
       */
      fact "Field Definition" {
        val model = '''
        skill StandardJavaLogging implements Logging {
          // A field is defined in the skill
          val logger = Logger.anonymousLogger
          def info(text : String) {
            logger.info(text)
          }
          def debug(text : String) {
            logger.fine(text)
          }
        }
        '''.parsesSuccessfully(
          "package io.sarl.docs.reference.sr
          import java.util.logging.Logger
          capacity Logging {
            // Log an information message
            def info(text : String)
            // Log a debugging message
            def debug(text : String)
          }",
          // TEXT
          ""
        )
        model.mustHavePackage("io.sarl.docs.reference.sr")
        model.mustHaveImports(1)
        model.mustHaveImport(0, "java.util.logging.Logger", false, false, false)
        model.mustHaveTopElements(2)
        var c = model.elements.get(0).mustBeCapacity("Logging").mustHaveFeatures(2)
        c.features.get(0).mustBeActionSignature("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        c.features.get(1).mustBeActionSignature("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        var s = model.elements.get(1).mustBeSkill("StandardJavaLogging", null, "io.sarl.docs.reference.sr.Logging").mustHaveFeatures(3)
        s.features.get(0).mustBeAttribute(false, "logger", null, true)
        s.features.get(1).mustBeAction("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s.features.get(2).mustBeAction("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
      }

      /* As for fields, it is possible to declare additional methods in the skill. 
       *  
       * @filter(.* = '''|'''|.parsesSuccessfully.*) 
       */
      fact "Action Definition" {
        val model = '''
        skill MyLogging implements Logging {
          def info(text : String) {
            output(text)
          }
          def debug(text : String) {
            output(text)
          }
          // Define an utility function
          // that is outputing the text
          def output(t : String) {
            System.err.println(t)
          }
        }
        '''.parsesSuccessfully(
          "package io.sarl.docs.reference.sr
          import java.util.logging.Logger
          capacity Logging {
            // Log an information message
            def info(text : String)
            // Log a debugging message
            def debug(text : String)
          }",
          // TEXT
          ""
        )
        model.mustHavePackage("io.sarl.docs.reference.sr")
        model.mustHaveImports(1)
        model.mustHaveImport(0, "java.util.logging.Logger", false, false, false)
        model.mustHaveTopElements(2)
        var c = model.elements.get(0).mustBeCapacity("Logging").mustHaveFeatures(2)
        c.features.get(0).mustBeActionSignature("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        c.features.get(1).mustBeActionSignature("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        var s = model.elements.get(1).mustBeSkill("MyLogging", null, "io.sarl.docs.reference.sr.Logging").mustHaveFeatures(3)
        s.features.get(0).mustBeAction("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s.features.get(1).mustBeAction("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s.features.get(2).mustBeAction("output", null, 1, false).mustHaveParameter(0, "t", "java.lang.String", false)
      }

      /* By default, it is not needed to specify a
       * constructor for the skills.
       * However, the definition of a constructor
       * is mandatory if a value must be initialized.
       *  
       * The constructors of the &lt;code&gt;Skill&lt;/code&gt; class
       * are: &lt;ul&gt;
       * &lt;li&gt;The default constructor: &lt;code&gt;def Skill()&lt;/code&gt;&lt;/li&gt;
       * &lt;li&gt;The constructor with owner: &lt;code&gt;def Skill(owner : Agent)&lt;/code&gt;&lt;/li&gt;
       * &lt;/ul&gt;
       * 
       * @filter(.* = '''|'''|.parsesSuccessfully.*) 
       */
      fact "Constructor Definition" {
        val model = '''
        skill StandardJavaLogging implements Logging {
          // A field is defined in the skill
          val logger : Logger
          // The constructor is mandatory
          // for defining the field "logger"
          new (l : Logger) {
            super() // Call the super's constructor
            logger = l
          }
          
          def info(text : String) {
            logger.info(text)
          }
          def debug(text : String) {
            logger.fine(text)
          }
        }
        '''.parsesSuccessfully(
          "package io.sarl.docs.reference.sr
          import java.util.logging.Logger
          capacity Logging {
            // Log an information message
            def info(text : String)
            // Log a debugging message
            def debug(text : String)
          }",
          // TEXT
          ""
        )
        model.mustHavePackage("io.sarl.docs.reference.sr")
        model.mustHaveImports(1)
        model.mustHaveImport(0, "java.util.logging.Logger", false, false, false)
        model.mustHaveTopElements(2)
        var c = model.elements.get(0).mustBeCapacity("Logging").mustHaveFeatures(2)
        c.features.get(0).mustBeActionSignature("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        c.features.get(1).mustBeActionSignature("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        var s = model.elements.get(1).mustBeSkill("StandardJavaLogging", null, "io.sarl.docs.reference.sr.Logging").mustHaveFeatures(4)
        s.features.get(0).mustBeAttribute(false, "logger", "java.util.logging.Logger", false)
        s.features.get(1).mustBeConstructor(1, false).mustHaveParameter(0, "l", "java.util.logging.Logger", false)
        s.features.get(2).mustBeAction("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s.features.get(3).mustBeAction("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
      }

      /* In some use cases, it is useful to define a skill by
       * implementing more than one capacity.
       * Below, the &lt;code&gt;MyLogging&lt;/code&gt; skill is defined as an implementation
       * of the capacities &lt;code&gt;Logging&lt;/code&gt; and &lt;code&gt;LogReader&lt;/code&gt;.
       * All the methods defined in the implemented interfaces must have
       * an implementation in the skill.
       * 
       * If two implemented capacities has the same action signature,
       * it must be implemented only once time in the skill.
       * 
       * @filter(.* = '''|'''|.parsesSuccessfully.*) 
       */
      fact "Multiple Capacity Implementation"{
        val model = '''
        capacity LogReader {
          def open(filename : String) : int
          def info(t : String)
          def close(fid : int)
        }
        skill MyLogging implements Logging, LogReader {
          // Shared implementation for the methods
          // defind in the two capacities.
          def info(text : String) {
            System.out.println(text)
          }
          def debug(text : String) {
            System.out.println(text)
          }
          def open(filename : String) : int {
            return 0
          }
          def close(fid : int) {
          }
        }
        '''.parsesSuccessfully(
          "package io.sarl.docs.reference.sr
          capacity Logging {
            // Log an information message
            def info(text : String)
            // Log a debugging message
            def debug(text : String)
          }",
          // TEXT
          ""
        )
        model.mustHavePackage("io.sarl.docs.reference.sr")
        model.mustNotHaveImport
        model.mustHaveTopElements(3)
        var c1 = model.elements.get(0).mustBeCapacity("Logging").mustHaveFeatures(2)
        c1.features.get(0).mustBeActionSignature("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        c1.features.get(1).mustBeActionSignature("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        var c2 = model.elements.get(1).mustBeCapacity("LogReader").mustHaveFeatures(3)
        c2.features.get(0).mustBeActionSignature("open", "int", 1, false).mustHaveParameter(0, "filename", "java.lang.String", false)
        c2.features.get(1).mustBeActionSignature("info", null, 1, false).mustHaveParameter(0, "t", "java.lang.String", false)
        c2.features.get(2).mustBeActionSignature("close", null, 1, false).mustHaveParameter(0, "fid", "int", false)
        var s = model.elements.get(2).mustBeSkill("MyLogging", null, "io.sarl.docs.reference.sr.Logging", "io.sarl.docs.reference.sr.LogReader").mustHaveFeatures(4)
        s.features.get(0).mustBeAction("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s.features.get(1).mustBeAction("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s.features.get(2).mustBeAction("open", "int", 1, false).mustHaveParameter(0, "filename", "java.lang.String", false)
        s.features.get(3).mustBeAction("close", null, 1, false).mustHaveParameter(0, "fid", "int", false)
      }

      /* In some use cases, it is useful to specialize the definition
       * of a skill. This mechanism is supported by the inheritance
       * feature of SARL, which has the same semantic as the inheritance
       * mechanism as the Java object-oriented language.
       * 
       * The extended skill is specified just after the &lt;code&gt;extends&lt;/code&gt;
       * keyword.
       * 
       * &lt;span class="label label-warning"&gt;Important&lt;/span&gt; A skill can
       * extend only one other skill type (same constrain as for
       * the classes in the Java language).
       * 
       * In the following code, the &lt;code&gt;StandardJavaLogging&lt;/code&gt; skill (defined
       * previously) is extended for changing the output of the info.
       * 
       * &lt;span class="label label-warning"&gt;Important&lt;/span&gt; A skill must implement
       * a capacity, even if it is extending an existing skill. It means that
       * the &lt;code&gt;implements&lt;/code&gt; must be given, even if the extended skill
       * is already implementing the capacity.
       * 
       * @filter(.* = '''|'''|.parsesSuccessfully.*) 
       */
      fact "Extending a Skill"{
        val model = '''
        skill ExtendedLogging extends StandardJavaLogging implements Logging {
          def info(text : String) {
            super.info("INFO: "+text)
          }
        }
        '''.parsesSuccessfully(
          "package io.sarl.docs.reference.sr
          import io.sarl.lang.core.Capacity
          capacity Logging {
            // Log an information message
            def info(text : String)
            // Log a debugging message
            def debug(text : String)
          }
          skill StandardJavaLogging implements Logging {
            def info(text : String) {
            }
            def debug(text : String) {
            }
          }",
          // TEXT
          ""
        )
        model.mustHavePackage("io.sarl.docs.reference.sr")
        model.mustHaveImports(1)
        model.mustHaveImport(0, "io.sarl.lang.core.Capacity", false, false, false)
        model.mustHaveTopElements(3)
        var c = model.elements.get(0).mustBeCapacity("Logging").mustHaveFeatures(2)
        c.features.get(0).mustBeActionSignature("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        c.features.get(1).mustBeActionSignature("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        var s1 = model.elements.get(1).mustBeSkill("StandardJavaLogging", null, "io.sarl.docs.reference.sr.Logging").mustHaveFeatures(2)
        s1.features.get(0).mustBeAction("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        s1.features.get(1).mustBeAction("debug", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)
        var s2 = model.elements.get(2).mustBeSkill("ExtendedLogging", "io.sarl.docs.reference.sr.StandardJavaLogging", "io.sarl.docs.reference.sr.Logging").mustHaveFeatures(1)
        s2.features.get(0).mustBeAction("info", null, 1, false).mustHaveParameter(0, "text", "java.lang.String", false)

        // TEST THE CAPACITY IMPLEMENTATION CONSTRAINT
        "  package io.sarl.docs.reference.sr
          import io.sarl.lang.core.Capacity
          capacity Logging {
            // Log an information message
            def info(text : String)
            // Log a debugging message
            def debug(text : String)
          }
          skill StandardJavaLogging implements Logging {
            def info(text : String) {
            }
            def debug(text : String) {
            }
          }
          skill ExtendedLogging extends StandardJavaLogging { // MISSED IMPLEMENTS KEYWORD
            def info(text : String) {
              super.info(\"INFO: \"+text)
            }
          }
        ".parsesWithError
      }

    }
    
    /* Several capacities are defined and reserved by the SARL Core
     * Specification. The corresponding skills are provided
     * by the runtime environment (such as the [Janus platform](http://www.janusproject.io)).
     * The builtin skills are described in the 
     * [Builtin Capacity Reference](./BuiltinCapacityReferenceSpec.html).
     */
    describe "Builtin Skills"{
    }

    /* Details on the use of the skills may be found in the references of
     * the major behavior-based concepts of SARL:&lt;ul&gt;
     * &lt;li&gt;[Agent](AgentReferenceSpec.html)&lt;/li&gt;
     * &lt;li&gt;[Behavior](BehaviorReferenceSpec.html)&lt;/li&gt;
     * &lt;/ul&gt;
     */
    describe "Use of the Skills"{
    }

}
</pre>
						    </div>
						  </div>
					</div> 
				</div> <!-- /row -->
			</div> <!-- /content -->
		</div> <!-- /tabbable -->
		<footer><p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>
</div> <!-- /container -->

</body>
</html>
