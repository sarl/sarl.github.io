<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<title>Builtin Capacity Reference</title>
<meta name="description" content="">
<meta name="author" content="Jnario">
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link rel="stylesheet" href="../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../css/custom.css">
<link rel="stylesheet" href="../../../../css/prettify.css">
<script type="text/javascript" src="../../../../js/prettify.js"></script><script type="text/javascript" src="../../../../js/lang-jnario.js"></script><script type="text/javascript" src="../../../../js/jquery.js"></script><script type="text/javascript" src="../../../../js/bootstrap-tab.js"></script>
</head>
<body onload="prettyPrint()">
<!-- Fixed navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">SARL</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="active"><a href="/">Home</a></li>
        <li><a href="/docs">Documentation</a></li>
        <li><a href="/download">Download</a></li>
        <li><a href="/news">News &amp; Events</a></li>
        <li><a href="/about">About</a></li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
</div>
	<div class="container">
		<div class="tabbable">
			<div class="content">
				<div class="page-header pending">
					<h1>Builtin Capacity Reference</h1>
					  <ul class="nav nav-tabs pull-right">
<li class="active"><a href="#spec" data-toggle="tab">Spec</a></li>
						<li><a href="#source" data-toggle="tab">Source</a></li>
					  </ul>
</div>
				<div class="row">
					<div class="span12">
						  <div class="tab-content">
							  	<div class="tab-pane active" id="spec">
<p>This document describes the builtin capacities in SARL. Before reading this document, it is recommended to read the <a href="./GeneralSyntaxReferenceSpec.html">General Syntax Reference</a>, the <a href="./CapacityReferenceSpec.html">Capacity Reference</a>, and the <a href="./SkillReferenceSpec.html">Skill Reference</a>.</p>
<p>A <em>Capacity</em> is the specification of a collection of actions. This specification makes no assumptions about its implementation. It could be used to specify what an agent can do, what a behavior requires for its execution.</p>
<p>A <em>Skill</em> is a possible implementation of a capacity fulfilling all the constraints of this specification.</p>
<p>Every agent in SARL has a set of <em>built-in capacities</em> considered essential to respect the commonly accepted competences of agents. These capacities are considered the main building blocks on top of which other higher level capacities and skills can be constructed. They are defined on the SARL language but the skill implementing them are provided by the runtime environment, e.g. the [Janus platform)(http://www.janus-project.io). This runtime environmentis responsible for creating them and injecting them on the agent before their execution begins. Therefore, when the agent receives the <code>Initialize</code> event they are already available.</p>
<p>The following figure presents the different contexts assocated to an agent. Several builtin capacities permit to access and manage these contexts. The agents are represented by stylized humans, the contexts by the blue boxes, and the spaces by the small colorized boxes in the contexts.</p>
<center><img alt="Contexts and Spaces" src="./Contexts.png" width="60%"></center>
<h3 class="exampleGroup passed" id="ExternalContextAccess">ExternalContextAccess</h3>
<p>The builtin capacity <code>ExternalContextAccess</code> provides access to the <a href="SpaceReferenceSpec.html">context</a> that the agent is a part of, and actions required to join new <a href="SpaceReferenceSpec.html">contexts</a>, and leave them.</p>
<p>The context supported by this builtin capacity is the "external contexts", illustrated by the top-right context in the figure above.</p>
<ul>
<li>
<p id="Retreiving_a_Context" class="example passed"><strong>Retreiving a Context</strong></p>
<p>For retreiving the context with a particular ID, this builtin capacity provides the following function:</p>
<pre class="prettyprint"> def getContext(contextID : UUID) : AgentContext </pre>
<p>The agent must have joined (see below) the context before calling this action or use its <code>parentContextID</code>.</p>
</li>
<li>
<p id="Retreiving_the_Contexts_of_an_Agent" class="example passed"><strong>Retreiving the Contexts of an Agent</strong></p>
<p>The following function enables an agent to retreive all the contexts in which it is involved:</p>
<pre class="prettyprint"> def getAllContexts : SynchronizedCollection<agentcontext></agentcontext></pre> The default context is included in the replied collection.
</li>
<li>
<p id="Joining_an_Existing_Context" class="example passed"><strong>Joining an Existing Context</strong></p>
<p>Agents must be able to join a new parent context. The following function gives this capability to them:</p>
<pre class="prettyprint"> def join(contextID : UUID, expectedDefaultSpaceID : UUID) </pre> This action registers the agent in the default space of the context.<p>The agent will be involved in the context with the ID given by <code>contextID</code>. The parameter <code>expectedDefaultSpaceID</code> is only used to check if the caller of this function knows the ID of the default space in the context to be involved in. If the given <code>expectedDefaultSpaceID</code> does not match the ID of the default space in the context <code>contextID</code>, then the access to the context is forbidden.</p>
<p><span class="label label-warning">Important</span> The context must already exists, and the default space inside this context must have the same ID as <code>expectedDefaultSpaceID</code>.</p>
<p>This action fires two events: </p>
<ul>
<li>
<code>ContextJoined</code> in its inner context default space.</li> <li>
<code>MemberJoined</code> in its parent context default space.</li> </ul>
</li>
<li>
<p id="Leaving_a_Context" class="example passed"><strong>Leaving a Context</strong></p>
<p>When an agent wants to leave a context, it must invoke:</p>
<pre class="prettyprint"> def leave(contextID : UUID) </pre>
<p>This action fires two events: </p>
<ul>
<li>
<code>ContextLeft</code> in its inner context default space.</li> <li>
<code>MemberLeft</code> in its parent context default space.</li> </ul>
</li>
</ul>
<h3 class="exampleGroup passed" id="InnerContextAccess">InnerContextAccess</h3>
<p>The builtin capacity <code>InnerContextAccess</code> provides access to the inner context of the agent. This is keystone for holonic agent implementation. The context supported by this builtin capacity is the "inner context", illustrated by the bottom context in the figure above.</p>
<ul>
<li>
<p id="Retreiving_the_Inner_Context" class="example passed"><strong>Retreiving the Inner Context</strong></p>
<p>For retreiving the inner context of an agent, this builtin capacity provides the following function:</p>
<pre class="prettyprint"> def getInnerContext : AgentContext </pre>
</li>
<li>
<p id="Members_of_an_Agent" class="example passed"><strong>Members of an Agent</strong></p>
<p>For retreiving information on the member agents of the current agent, several functions are provided by this builtin capacity. A member agent is an agent which is not the calling agent, and is a member of at least one space of the inner context.</p>
<p>The first function replies if the calling agent has other agents as members of its inner context: </p>
<pre class="prettyprint"> def hasMemberAgent : boolean </pre>
<p>The second function replies the number of agents that are members of the inner context of the calling agent: </p>
<pre class="prettyprint"> def getMemberAgentCount : int </pre>
<p>The third function replies all the member agents in the inner context: </p>
<pre class="prettyprint"> def getMemberAgents : SynchronizedSet<uuid></uuid></pre>
</li>
</ul>
<h3 class="exampleGroup passed" id="DefaultContextInteractions">DefaultContextInteractions</h3>
<p>The <code>DefaultContextInteractions</code> capacity is actually provided for convenience. It assumes that the action will be performed on the agent's <em>default context</em> and its <em>default space</em>. These context and space are illustrated by the top-left context in the figure above.</p>
<p>For instance, the <code>emit</code> action is a shortcut for:</p>
<pre class="prettyprint"> defaultContext.defaultSpace.emit(...) </pre> Therefore, it is actually created on top of the other builtin capacities.
<ul>
<li>
<p id="Retreiving_the_Default_Context_and_Space" class="example passed"><strong>Retreiving the Default Context and Space</strong></p>
<p>For retreiving the default context of an agent, this builtin capacity provides the following function:</p>
<pre class="prettyprint"> def getDefaultContext : AgentContext </pre>
<p>For retreiving the default space in the default context of an agent, this builtin capacity provides the following function:</p>
<pre class="prettyprint"> def getDefaultSpace : EventSpace </pre>
<p>For obtaining the address of the agent in the default space, the following function is provided: </p>
<pre class="prettyprint"> def getDefaultAddress : Address </pre>
</li>
<li>
<p id="Spawning_an_Agent" class="example passed"><strong>Spawning an Agent</strong></p>
<p>Most of the time, it is necessary for agent to create a new agent into the default context. The following function is provided for this task: </p>
<pre class="prettyprint"> def spawn(agentType : Class&lt;? extends Agent&gt;, params : Object[]) : UUID </pre>
<p>This action creates an instance of the given agent type, and launchs the agent into the default context. The parameters are passed to the spawned agent inside the <code>Initialize</code> event: the <code>parameters</code> field.</p>
<p>This action fires two events: </p>
<ul>
<li>
<code>AgentSpawned</code> in the default space of the default context. The source of the event is this spawning agent.</li> <li>
<code>Initialize</code> in spawned agent.</li> </ul>
</li>
<li>
<p id="Emitting_an_Event_in_the_Default_Space" class="example passed"><strong>Emitting an Event in the Default Space</strong></p>
<p>The core mechanism for information exchanges among agents is <a href="./EventReferenceSpec.html">event-based</a>. For emitting an event in the default space of the default context, the following function is provided: </p>
<pre class="prettyprint"> def emit(e : Event) </pre> This function emits a given event with no scope (all registered agent will receive the event) in the default space of the default context.<p>It is equivalent to: </p>
<pre class="prettyprint"> defaultContext.defaultSpace.emit(e) </pre>
</li>
<li>
<p id="Emitting_an_Event_to_Specific_Agents_in_the_Default_Space" class="example passed"><strong>Emitting an Event to Specific Agents in the Default Space</strong></p>
<p>The previous emitting function assumes that there is no restriction on the set of the receivers of the event. It is possible to specify a <code>Scope</code> for applying a restriction. </p>
<pre class="prettyprint"> def emit(e : Event, scope : Scope<address>) </address></pre>
<p>A scope is a predicates that is evaluated against the address of the receiver. It is defined as (in Java): </p>
<pre class="prettyprint"> public interface Scope<t> extends Serializable {  public boolean matches(T element); } </t></pre>
<p>A default implementation of a scope using addresses is provided: <code>io.sarl.util.AddressScope</code>.</p>
<p>You must also use the utilities functions for creating scopes. They are defined in the class <code>io.sarl.util.Scopes</code>. The following example is equivalent to the feature call of <code>emit</code> without the scoping parameter: </p>
<pre class="prettyprint"> emit(new Event, Scopes::allParticipants) </pre>
<p>You are free to create new implementation of <code>Scope</code> in order to filter the receivers of an event according to your own critera.</p>
</li>
</ul>
<h3 class="exampleGroup passed" id="Lifecycle">Lifecycle</h3>
<p>The builtin capacity <code>Lifecycle</code> provides actions to spawn new agents on different external contexts and the innner context, as well as the <code>killMe</code> action to stop its own execution.</p>
<ul>
<li>
<p id="Stopping_the_Agent_Execution" class="example passed"><strong>Stopping the Agent Execution</strong></p>
<p>Because of the autonomy property of an agent, it can be stopped only be commiting a suicide. It means that it is impossible to stop an agent's from another agent: the agent to stop must be able to accept or reject this query.</p>
<p>The <code>Lifecycle</code> capacity provides the following function for committing a suicide: </p>
<pre class="prettyprint"> def killMe </pre>
<p>This action must automatically unregister this agent from the default context and therefore all its spaces including the default space.</p>
<p><span class="label label-warning">Important</span> If this is a composed agent, it must not have any members before calling this action. Otherwise a RuntimeException will be thrown.</p>
<p>This action fires two events: </p>
<ul>
<li>
<code>AgentKilled</code> in the default space of all contexts to which this agent belongs.</li> <li>
<code>Destroy</code> inside the agent.</li> </ul>
</li>
<li>
<p id="Spawning_an_Agent" class="example passed"><strong>Spawning an Agent</strong></p>
<p>Most of the time, it is necessary for agent to create a new agent into a given context. The following function is provided for this task: </p>
<pre class="prettyprint"> def spawnInContext(agentType : Class&lt;? extends Agent&gt;, context : AgentContext, params : Object[]) : UUID </pre>
<p>This action creates an instance of the given agent type, and launchs the agent into the given context. The parameters are passed to the spawned agent inside the <code>Initialize</code> event: the <code>parameters</code> field.</p>
<p>This action fires two events: </p>
<ul>
<li>
<code>AgentSpawned</code> in the default space of the context. The source of the event is this spawning agent.</li> <li>
<code>Initialize</code> in spawned agent.</li> </ul>
</li>
</ul>
<h3 class="exampleGroup passed" id="Schedules">Schedules</h3>
<p>The builtin capacity <code>Schedules</code> enables the agent to schedule tasks for future or periodic execution.</p>
<ul>
<li>
<p id="Creating_Named_Tasks" class="example passed"><strong>Creating Named Tasks</strong></p>
<p>A named task may be created with: </p>
<pre class="prettyprint"> def task(name : String) : AgentTask </pre> The replied task may be used for future execution, or controlling the execution.
</li>
<li>
<p id="Launching_a_Delayed_Task" class="example passed"><strong>Launching a Delayed Task</strong></p>
<p>For running a task in a given delay, the following functions are provided: </p>
<pre class="prettyprint"> def in(delay : long, procedure : (Agent) =&gt; void) : AgentTask def in(task : AgentTask, delay : long, procedure : (Agent) =&gt; void) : AgentTask </pre>
<p>The first function submits the given procedure (a lambda expression as defined in the <a href="./GeneralSyntaxReferenceSpec.html">General Syntax Reference</a>) to an executor provided by the runtime platform. The execution of the procedure will be delayed during the given number of milliseconds. This function replies the agent task for controlling its execution.</p>
<p>The second function behaves in a similar way as the first, except that it accepts an agent task as parameter. This task will attached to the given procedure. The replied task is the same as the task given as parameter.</p>
</li>
<li>
<p id="Launching_a_Periodic_Task" class="example passed"><strong>Launching a Periodic Task</strong></p>
<p>For running a periodic task, the following functions are provided: </p>
<pre class="prettyprint"> def every(period : long, procedure : (Agent) =&gt; void) : AgentTask def every(period : AgentTask, delay : long, procedure : (Agent) =&gt; void) : AgentTask </pre>
<p>The first function submits the given procedure (a lambda expression as defined in the <a href="./GeneralSyntaxReferenceSpec.html">General Syntax Reference</a>) to an executor provided by the runtime platform. The execution of the procedure will be launched periodically with a period of the given number of milliseconds. This function replies the agent task for controlling its execution.</p>
<p>The second function behaves in a similar way as the first, except that it accepts an agent task as parameter. This task will attached to the given procedure. The replied task is the same as the task given as parameter.</p>
</li>
<li>
<p id="Cancelling_a_Task" class="example passed"><strong>Cancelling a Task</strong></p>
<p>It may be useful to cancel a running task, e.g. a periodic task. The <code>Schedules</code> capacity provides two functions for stopping the execution of an agent task: </p>
<pre class="prettyprint"> def cancel(task : AgentTask) : boolean def cancel(task : AgentTask, mayInterruptIfRunning : boolean) : boolean </pre>
<p>These functions will fail if the task has already completed, has already been cancelled, or could not be cancelled for some other reason (a failure means replying false). If successful, and this task has not started when <code>cancel</code> is called, this task should never run. If the task has already started, then the <code>mayInterruptIfRunning</code> parameter determines whether the thread executing this task should be interrupted in an attempt to stop the task.</p>
<p>The first function interrupts ongoing tasks. So, it is equivalent to passing <code>true</code> as the value for the parameter <tt>mayInterruptIfRunning</tt> to the function <code>cancel(AgentTask, boolean)</code>.</p>
</li>
</ul>
<h3 class="exampleGroup passed" id="Behaviors">Behaviors</h3>
<p>The builtin capacity <code>Behaviors</code> provides the tools to the agents for dynamically registered and unregistered sub-behaviors.</p>
<p>This capacity is closely related to the <code>InnerContextAccess</code> to enable a high-level abstraction on holonic multiagent system development.</p>
<p>The definition of a behavior is not detailled in this reference document. Please read the <a href="BehaviorReferenceSpec.html">Behavior Reference</a> for details.</p>
<ul>
<li>
<p id="Registering_a_Behavior" class="example passed"><strong>Registering a Behavior</strong></p>
<p>Assuming that a behavior was already defined, it is possible for an agent to register with behavior: </p>
<pre class="prettyprint"> def registerBehavior(attitude : Behavior) : Behavior </pre> This function takes the behavior to be registered, and replies the same behavior. When a behavior is registering, it is receiving the events in the default space of the inner context of the agent, or received by the agent.
</li>
<li>
<p id="Unregistering_a_Behavior" class="example passed"><strong>Unregistering a Behavior</strong></p>
<p>Assuming that a behavior was already registered, it is possible for an agent to unregister it: </p>
<pre class="prettyprint"> def unregisterBehavior(attitude : Behavior) : Behavior </pre> This function takes the behavior to be registered, and replies the same behavior. When a behavior is unregistering, it is no more receiving the events in the default space of the inner context of the agent, and received by the agent.
</li>
<li>
<p id="Executing_a_Behavior" class="example passed"><strong>Executing a Behavior</strong></p>
<p>A behavior is executed through its event handlers. Consequently, for running a behavior, it is mandatory to wake it with an event. This particular feature is supported by: </p>
<pre class="prettyprint"> def wake(evt : Event) </pre>
<p>This function emits the given event into the inner context of the agent (in its default space).</p>
<p><span class="label label-warning">Important</span> It is not possible to execute a particular behavior. All the behaviors waiting for a given event will be executed by this function.</p>
</li>
<li>
<p id="Creating_an_Event_Listener" class="example passed"><strong>Creating an Event Listener</strong></p>
<p>Sometimes, it is useful or mandatory for an agent to listen on the events in a given space. The following function permits to retreive the event listener of the agent: </p>
<pre class="prettyprint"> def asEventListener : EventListener </pre>
<p>The listener replied by this function is the one used by the agent (and its behaviors) for listening events related to all the contexts (default, external, and inner).</p>
</li>
</ul>
<h3 class="exampleGroup pending" id="Use_of_the_Builtin_Capacities">Use of the Builtin Capacities</h3>
<p>Details on the use of the builtin capacities may be found in the references of the major behavior-based concepts of SARL:</p>
<ul>
<li><a href="AgentReferenceSpec.html">Agent</a></li> <li><a href="BehaviorReferenceSpec.html">Behavior</a></li> </ul>
</div>
						    <div class="tab-pane" id="source">
						    	<h3>BIC.spec</h3>
						    	<p>
</p>
<pre class="prettyprint lang-spec linenums">
/*
 * Copyright 2014 Sebastian RODRIGUEZ, Nicolas GAUD, St√©phane GALLAND
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.docs.reference

import com.google.inject.Inject
import io.sarl.docs.utils.SARLParser
import io.sarl.docs.utils.SARLSpecCreator
import org.jnario.runner.CreateWith

/**
 * This document describes the builtin capacities in SARL.
 * Before reading this document, it is recommended to read
 * the [General Syntax Reference](./GeneralSyntaxReferenceSpec.html),
 * the [Capacity Reference](./CapacityReferenceSpec.html),
 * and the [Skill Reference](./SkillReferenceSpec.html).
 * 
 * A *Capacity* is the specification of a collection of actions. This specification 
 * makes no assumptions about its implementation. It could be used to specify 
 * what an agent can do, what a behavior requires for its execution.
 * 
 * A *Skill* is a possible implementation of a capacity fulfilling all the 
 * constraints of this specification.
 * 
 * Every agent in SARL has a set of *built-in capacities* considered essential 
 * to respect the commonly accepted competences of agents.
 * These capacities are considered the main building blocks on top of which other 
 * higher level capacities and skills can be constructed.
 * They are defined on the SARL language but the skill implementing them are provided 
 * by the runtime environment, e.g. the [Janus platform)(http://www.janus-project.io).
 * This runtime environmentis responsible for creating them and injecting them on 
 * the agent before their execution begins.
 * Therefore, when the agent receives the &lt;code&gt;Initialize&lt;/code&gt; event they are
 * already available.
 * 
 * The following figure presents the different contexts assocated to an agent.
 * Several builtin capacities permit to access and manage these contexts.
 * The agents are represented by stylized humans, the contexts by the blue boxes,
 * and the spaces by the small colorized boxes in the contexts.
 * 
 * &lt;center&gt;&lt;img alt="Contexts and Spaces" src="./Contexts.png" width="60%" /&gt;&lt;/center&gt;
 */
@CreateWith(SARLSpecCreator)
describe "Builtin Capacity Reference" {

    @Inject extension SARLParser

    /* The builtin capacity &lt;code&gt;ExternalContextAccess&lt;/code&gt; provides access to the 
     * [context](SpaceReferenceSpec.html) that the agent is a part of, and actions
     * required to join new [contexts](SpaceReferenceSpec.html), and leave them.
     * 
     * The context supported by this builtin capacity is the "external contexts",
     * illustrated by the top-right context in the figure above.
     */
    describe "ExternalContextAccess" {
      
      /*  For retreiving the context with a particular ID,
       * this builtin capacity provides the following function:&lt;pre&gt;&lt;code&gt;
       * def getContext(contextID : UUID) : AgentContext
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The agent must have joined (see below) the context before calling this 
       * action or use its &lt;code&gt;parentContextID&lt;/code&gt;.
       *  
       * @filter(.*) 
       */
      fact "Retreiving a Context"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.ExternalContextAccess
          import io.sarl.lang.core.AgentContext
          import java.util.UUID
          agent A {
            uses ExternalContextAccess
            def myaction {
              var id : UUID
              var c : AgentContext
              id = UUID::randomUUID
              c = getContext(id)
            }
          }".parsesSuccessfully
      }
      
      /* The following function enables an agent to retreive
       * all the contexts in which it is involved:&lt;pre&gt;&lt;code&gt;
       * def getAllContexts : SynchronizedCollection&lt;AgentContext&gt;
       * &lt;/code&gt;&lt;/pre&gt;
       * The default context is included in the replied collection.
       *  
       * @filter(.*) 
       */
      fact "Retreiving the Contexts of an Agent"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.ExternalContextAccess
          import io.sarl.lang.core.AgentContext
          import io.sarl.lang.util.SynchronizedCollection
          agent A {
            uses ExternalContextAccess
            def myaction {
              var c : SynchronizedCollection&lt;AgentContext&gt;
              c = getAllContexts
            }
          }".parsesSuccessfully
      }
      
      /* Agents must be able to join a new parent context.
       * The following function gives this capability to them:&lt;pre&gt;&lt;code&gt;
       * def join(contextID : UUID, expectedDefaultSpaceID : UUID)
       * &lt;/code&gt;&lt;/pre&gt;
       * This action registers the agent in the default space of the context.
       * 
       * The agent will be involved in the context with the ID given by &lt;code&gt;contextID&lt;/code&gt;.
       * The parameter &lt;code&gt;expectedDefaultSpaceID&lt;/code&gt; is only used to check if
       * the caller of this function knows the ID of the default space in the context to
       * be involved in. 
       * If the given &lt;code&gt;expectedDefaultSpaceID&lt;/code&gt; does not match the ID of the
       * default space in the context &lt;code&gt;contextID&lt;/code&gt;, then the access to the context
       * is forbidden.
       * 
       * &lt;span class="label label-warning"&gt;Important&lt;/span&gt; The context must already 
       * exists, and the default space inside this context must have the same ID 
       * as &lt;code&gt;expectedDefaultSpaceID&lt;/code&gt;.
       * 
       * This action fires two events: &lt;ul&gt;
       * &lt;li&gt;&lt;code&gt;ContextJoined&lt;/code&gt; in its inner context default space.&lt;/li&gt;
       * &lt;li&gt;&lt;code&gt;MemberJoined&lt;/code&gt; in its parent context default space.&lt;/li&gt;
       * &lt;/ul&gt;
       *  
       * @filter(.*) 
       */
      fact "Joining an Existing Context"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.ExternalContextAccess
          import java.util.UUID
          agent A {
            uses ExternalContextAccess
            def myaction {
              var idc : UUID
              var ids : UUID
              idc = UUID::randomUUID
              ids = UUID::randomUUID
              join(idc, ids)
            }
          }".parsesSuccessfully
      }

      /* When an agent wants to leave a context, it must invoke:&lt;pre&gt;&lt;code&gt;
       * def leave(contextID : UUID)
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * This action fires two events: &lt;ul&gt;
       * &lt;li&gt;&lt;code&gt;ContextLeft&lt;/code&gt; in its inner context default space.&lt;/li&gt;
       * &lt;li&gt;&lt;code&gt;MemberLeft&lt;/code&gt; in its parent context default space.&lt;/li&gt;
       * &lt;/ul&gt;
       *  
       * @filter(.*) 
       */
      fact "Leaving a Context"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.ExternalContextAccess
          import java.util.UUID
          agent A {
            uses ExternalContextAccess
            def myaction {
              var idc : UUID
              idc = UUID::randomUUID
              leave(idc)
            }
          }".parsesSuccessfully
      }
    
    }

    /* The builtin capacity &lt;code&gt;InnerContextAccess&lt;/code&gt; provides access to 
     * the inner context of the agent.
     * This is keystone for holonic agent implementation.
     * The context supported by this builtin capacity is the "inner context",
     * illustrated by the bottom context in the figure above.
     */
    describe "InnerContextAccess" {
      
      /* For retreiving the inner context of an agent,
       * this builtin capacity provides the following function:&lt;pre&gt;&lt;code&gt;
       * def getInnerContext : AgentContext
       * &lt;/code&gt;&lt;/pre&gt;
       *  
       * @filter(.*) 
       */
      fact "Retreiving the Inner Context"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.InnerContextAccess
          import io.sarl.lang.core.AgentContext
          agent A {
            uses InnerContextAccess
            def myaction {
              var c : AgentContext
              c = getInnerContext
            }
          }".parsesSuccessfully
      }

      /* For retreiving information on the member agents of the current agent,
       * several functions are provided by this builtin capacity.
       * A member agent is an agent which is not the
       * calling agent, and is a member of at least
       * one space of the inner context.
       * 
       * The first function replies if the calling agent has other agents
       * as members of its inner context: &lt;pre&gt;&lt;code&gt;
       * def hasMemberAgent : boolean
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The second function replies the number of agents that are members
       * of the inner context of the calling agent: &lt;pre&gt;&lt;code&gt;
       * def getMemberAgentCount : int
       * &lt;/code&gt;&lt;/pre&gt;
       *
       * The third function replies all the member agents in the inner
       * context: &lt;pre&gt;&lt;code&gt;
       * def getMemberAgents : SynchronizedSet&lt;UUID&gt;
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * @filter(.*) 
       */
      fact "Members of an Agent"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.InnerContextAccess
          import io.sarl.lang.util.SynchronizedSet
          import java.util.UUID
          agent A {
            uses InnerContextAccess
            def myaction {
              var b : boolean
              var n : int
              var m : SynchronizedSet&lt;UUID&gt;
              b = hasMemberAgent
              n = getMemberAgentCount
              m = getMemberAgents
            }
          }".parsesSuccessfully
      }

    }
    
    /* The &lt;code&gt;DefaultContextInteractions&lt;/code&gt; capacity is actually provided
     * for convenience. It assumes that the action will be performed on the 
     * agent's *default context* and its *default space*. These context and space
     * are illustrated by the top-left context in the figure above. 
     * 
     * For instance, the &lt;code&gt;emit&lt;/code&gt; action is a shortcut for:&lt;pre&gt;&lt;code&gt;
     * defaultContext.defaultSpace.emit(...)
     * &lt;/code&gt;&lt;/pre&gt;
     * Therefore, it is actually created on top of the other builtin capacities.
     */
    describe "DefaultContextInteractions" {
      
      /* For retreiving the default context of an agent,
       * this builtin capacity provides the following function:&lt;pre&gt;&lt;code&gt;
       * def getDefaultContext : AgentContext
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * For retreiving the default space in the default context of an agent,
       * this builtin capacity provides the following function:&lt;pre&gt;&lt;code&gt;
       * def getDefaultSpace : EventSpace
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * For obtaining the address of the agent in the default space,
       * the following function is provided: &lt;pre&gt;&lt;code&gt;
       * def getDefaultAddress : Address
       * &lt;/code&gt;&lt;/pre&gt;
       *  
       * @filter(.*) 
       */
      fact "Retreiving the Default Context and Space"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.DefaultContextInteractions
          import io.sarl.lang.core.AgentContext
          import io.sarl.lang.core.EventSpace
          import io.sarl.lang.core.Address
          agent A {
            uses DefaultContextInteractions
            def myaction {
              var c : AgentContext
              var e : EventSpace
              var a : Address
              c = getDefaultContext
              e = getDefaultSpace
              a = getDefaultAddress
            }
          }".parsesSuccessfully
      }
  
      /* Most of the time, it is necessary for agent to create a new agent
       * into the default context. The following function is provided for this
       * task:
       * &lt;pre&gt;&lt;code&gt;
       * def spawn(agentType : Class&lt;? extends Agent&gt;, params : Object[]) : UUID
       * &lt;/code&gt;&lt;/pre&gt;
       *
       * This action creates an instance of the given agent type, and launchs the agent
       * into the default context. The parameters are passed to the spawned agent inside
       * the &lt;code&gt;Initialize&lt;/code&gt; event: the &lt;code&gt;parameters&lt;/code&gt; field.
       * 
       * This action fires two events: &lt;ul&gt;
       * &lt;li&gt;&lt;code&gt;AgentSpawned&lt;/code&gt; in the default space of the default context. The source of the event is this spawning agent.&lt;/li&gt;
       * &lt;li&gt;&lt;code&gt;Initialize&lt;/code&gt; in spawned agent.&lt;/li&gt;
       * &lt;/ul&gt;
       *  
       * @filter(.*) 
       */
      fact "Spawning an Agent"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.DefaultContextInteractions
          import io.sarl.lang.core.Agent
          import java.util.UUID
          agent A {
            uses DefaultContextInteractions
            def myaction {
              var aid : UUID
              var type : Class&lt;? extends Agent&gt;
              var p1 : Object
              var p2 : Object
              type = typeof(A)
              p1 = new Object
              p2 = new Object
              aid = spawn(type, #[p1, p2])
            }
          }".parsesSuccessfully
      }

      /* The core mechanism for information exchanges among agents is
       * [event-based](./EventReferenceSpec.html).
       * For emitting an event in the default space of the default context,
       * the following function is provided: &lt;pre&gt;&lt;code&gt;
       * def emit(e : Event)
       * &lt;/code&gt;&lt;/pre&gt; 
       * This function emits a given event with no scope (all registered agent will
       * receive the event) in the default space of the default context.
       * 
       * It is equivalent to: &lt;pre&gt;&lt;code&gt;
       * defaultContext.defaultSpace.emit(e)
       * &lt;/code&gt;&lt;/pre&gt;
       *  
       * @filter(.*) 
       */
      fact "Emitting an Event in the Default Space"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.DefaultContextInteractions
          event E
          agent A {
            uses DefaultContextInteractions
            def myaction {
              var e : E
              e = new E
              emit(e)
            }
          }".parsesSuccessfully
      }

      /* The previous emitting function assumes that there is no
       * restriction on the set of the receivers of the event.
       * It is possible to specify a &lt;code&gt;Scope&lt;/code&gt; for
       * applying a restriction.
       * &lt;pre&gt;&lt;code&gt;
       * def emit(e : Event, scope : Scope&lt;Address&gt;)
       * &lt;/code&gt;&lt;/pre&gt; 
       * 
       * A scope is a predicates that is evaluated against the
       * address of the receiver. It is defined as (in Java): &lt;pre&gt;&lt;code&gt;
       * public interface Scope&lt;T&gt; extends Serializable {
       *     public boolean matches(T element);
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * A default implementation of a scope using addresses is provided:
       * &lt;code&gt;io.sarl.util.AddressScope&lt;/code&gt;.
       * 
       * You must also use the utilities functions for creating scopes.
       * They are defined in the class &lt;code&gt;io.sarl.util.Scopes&lt;/code&gt;.
       * The following example is equivalent to the feature call of
       * &lt;code&gt;emit&lt;/code&gt; without the scoping parameter: &lt;pre&gt;&lt;code&gt;
       * emit(new Event, Scopes::allParticipants)
       * &lt;/code&gt;&lt;/pre&gt; 
       * 
       * 
       * You are free to create new implementation of &lt;code&gt;Scope&lt;/code&gt;
       * in order to filter the receivers of an event according to your
       * own critera.
       *  
       * @filter(.*) 
       */
      fact "Emitting an Event to Specific Agents in the Default Space"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.DefaultContextInteractions
          import io.sarl.util.AddressScope
          import io.sarl.util.Scopes
          event E
          agent A {
            uses DefaultContextInteractions
            def myaction {
              var e : E
              e = new E
              emit(e, AddressScope::getScope)
              emit(e, Scopes::allParticipants)
            }
          }".parsesSuccessfully
      }

    }

    /* The builtin capacity &lt;code&gt;Lifecycle&lt;/code&gt; provides actions to 
     * spawn new agents on different external contexts and 
     * the innner context, as well as the &lt;code&gt;killMe&lt;/code&gt; action to stop 
     * its own execution.
     */
    describe "Lifecycle" {
      
      /* Because of the autonomy property of an agent, it can be stopped
       * only be commiting a suicide. It means that it is impossible to
       * stop an agent's from another agent: the agent to stop must
       * be able to accept or reject this query.
       * 
       * The &lt;code&gt;Lifecycle&lt;/code&gt; capacity provides the following function
       * for committing a suicide:
       * &lt;pre&gt;&lt;code&gt;
       * def killMe
       * &lt;/code&gt;&lt;/pre&gt;
       *
       * This action must automatically unregister this agent from the default context
       * and therefore all its spaces including the default space.
       * 
       * &lt;span class="label label-warning"&gt;Important&lt;/span&gt; If this is a composed agent,
       * it must not have any members before calling this action. Otherwise a 
       * RuntimeException will be thrown.
       * 
       * This action fires two events: &lt;ul&gt;
       * &lt;li&gt;&lt;code&gt;AgentKilled&lt;/code&gt; in the default space of all contexts to which this agent belongs.&lt;/li&gt;
       * &lt;li&gt;&lt;code&gt;Destroy&lt;/code&gt; inside the agent.&lt;/li&gt;
       * &lt;/ul&gt;
       *  
       * @filter(.*) 
       */
      fact "Stopping the Agent Execution"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Lifecycle
          agent A {
            uses Lifecycle
            def myaction {
              killMe
            }
          }".parsesSuccessfully
      }

      /* Most of the time, it is necessary for agent to create a new agent
       * into a given context. The following function is provided for this
       * task:
       * &lt;pre&gt;&lt;code&gt;
       * def spawnInContext(agentType : Class&lt;? extends Agent&gt;, context : AgentContext, params : Object[]) : UUID
       * &lt;/code&gt;&lt;/pre&gt;
       *
       * This action creates an instance of the given agent type, and launchs the agent
       * into the given context. The parameters are passed to the spawned agent inside
       * the &lt;code&gt;Initialize&lt;/code&gt; event: the &lt;code&gt;parameters&lt;/code&gt; field.
       * 
       * This action fires two events: &lt;ul&gt;
       * &lt;li&gt;&lt;code&gt;AgentSpawned&lt;/code&gt; in the default space of the context. The source of the event is this spawning agent.&lt;/li&gt;
       * &lt;li&gt;&lt;code&gt;Initialize&lt;/code&gt; in spawned agent.&lt;/li&gt;
       * &lt;/ul&gt;
       *  
       * @filter(.*) 
       */
      fact "Spawning an Agent"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Lifecycle
          import io.sarl.lang.core.AgentContext
          import io.sarl.lang.core.Agent
          import java.util.UUID
          agent A {
            uses Lifecycle
            def myaction {
              var c : AgentContext
              var aid : UUID
              var type : Class&lt;? extends Agent&gt;
              var p1 : Object
              var p2 : Object
              type = typeof(A)
              p1 = new Object
              p2 = new Object
              aid = spawnInContext(type, c, #[p1, p2])
            }
          }".parsesSuccessfully
      }

    }

    /* The builtin capacity &lt;code&gt;Schedules&lt;/code&gt; enables the agent to 
     * schedule tasks for future or periodic execution.
     */
    describe "Schedules" {
      
      /* A named task may be created with: &lt;pre&gt;&lt;code&gt;
       * def task(name : String) : AgentTask
       * &lt;/code&gt;&lt;/pre&gt;
       * The replied task may be used for future execution, or
       * controlling the execution.
       * 
       * @filter(.*) 
       */
      fact "Creating Named Tasks"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Schedules
          import io.sarl.core.AgentTask
          agent A {
            uses Schedules
            def myaction {
              var n : String
              var t : AgentTask
              n = \"abc\"
              t = task(n)
            }
          }".parsesSuccessfully
      }

      /* For running a task in a given delay, the following functions are
       * provided: &lt;pre&gt;&lt;code&gt;
       * def in(delay : long, procedure : (Agent) =&gt; void) : AgentTask
       * def in(task : AgentTask, delay : long, procedure : (Agent) =&gt; void) : AgentTask
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The first function submits the given procedure (a lambda expression as defined in
       * the [General Syntax Reference](./GeneralSyntaxReferenceSpec.html)) to
       * an executor provided by the runtime platform. The execution of the procedure
       * will be delayed during the given number of milliseconds.
       * This function replies the agent task for controlling its execution.
       * 
       * The second function behaves in a similar way as the first, except that it
       * accepts an agent task as parameter. This task will attached to the given
       * procedure. The replied task is the same as the task given as parameter.
       * 
       * @filter(.*) 
       */
      fact "Launching a Delayed Task"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Schedules
          import io.sarl.core.AgentTask
          import io.sarl.lang.core.Agent
          agent A {
            uses Schedules
            def myaction {
              var t1 : AgentTask
              var t2 : AgentTask
              t1 = in(1000) [ a : Agent |
                println(a)
              ]
              t1 = t2.in(1000) [ a : Agent |
                println(a)
              ]
            }
          }".parsesSuccessfully
      }

      /* For running a periodic task, the following functions are
       * provided: &lt;pre&gt;&lt;code&gt;
       * def every(period : long, procedure : (Agent) =&gt; void) : AgentTask
       * def every(period : AgentTask, delay : long, procedure : (Agent) =&gt; void) : AgentTask
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The first function submits the given procedure (a lambda expression as defined in
       * the [General Syntax Reference](./GeneralSyntaxReferenceSpec.html)) to
       * an executor provided by the runtime platform. The execution of the procedure
       * will be launched periodically with a period of the given number of milliseconds.
       * This function replies the agent task for controlling its execution.
       * 
       * The second function behaves in a similar way as the first, except that it
       * accepts an agent task as parameter. This task will attached to the given
       * procedure. The replied task is the same as the task given as parameter.
       * 
       * @filter(.*) 
       */
      fact "Launching a Periodic Task"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Schedules
          import io.sarl.core.AgentTask
          import io.sarl.lang.core.Agent
          agent A {
            uses Schedules
            def myaction {
              var t1 : AgentTask
              var t2 : AgentTask
              t1 = every(1000) [ a : Agent |
                println(a)
              ]
              t1 = t2.every(1000) [ a : Agent |
                println(a)
              ]
            }
          }".parsesSuccessfully
      }

      /* It may be useful to cancel a running task, e.g. a
       * periodic task. The &lt;code&gt;Schedules&lt;/code&gt; capacity
       * provides two functions for stopping the execution
       * of an agent task: &lt;pre&gt;&lt;code&gt;
       * def cancel(task : AgentTask) : boolean
       * def cancel(task : AgentTask, mayInterruptIfRunning : boolean) : boolean
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * These functions will fail if the task has already completed, has 
       * already been cancelled, or could not be cancelled for some other reason
       * (a failure means replying false). 
       * If successful, and this task has not started when &lt;code&gt;cancel&lt;/code&gt; is
       * called, this task should never run. If the task has already started,
       * then the &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; parameter determines
       * whether the thread executing this task should be interrupted in
       * an attempt to stop the task.
       * 
       * The first function interrupts ongoing tasks. So, it is equivalent to 
       * passing &lt;code&gt;true&lt;/code&gt; as the value for the parameter 
       * &lt;tt&gt;mayInterruptIfRunning&lt;/tt&gt; to the function
       * &lt;code&gt;cancel(AgentTask, boolean)&lt;/code&gt;.
       * 
       * @filter(.*) 
       */
      fact "Cancelling a Task"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Schedules
          import io.sarl.core.AgentTask
          agent A {
            uses Schedules
            def myaction {
              var t1 : AgentTask
              var t2 : AgentTask
              var t3 : AgentTask
              t1.cancel
              t2.cancel(true)
              t3.cancel(false)
            }
          }".parsesSuccessfully
      }

    }

    /* The builtin capacity &lt;code&gt;Behaviors&lt;/code&gt; provides the tools to the agents 
     * for dynamically registered and unregistered sub-behaviors.
     * 
     * This capacity is closely related to the &lt;code&gt;InnerContextAccess&lt;/code&gt; to 
     * enable a high-level abstraction on holonic multiagent system development.
     * 
     * The definition of a behavior is not detailled in this reference document.
     * Please read the [Behavior Reference](BehaviorReferenceSpec.html) for details.
     */
    describe "Behaviors" {
      
      /* Assuming that a behavior was already defined,
       * it is possible for an agent to register with behavior: &lt;pre&gt;&lt;code&gt;
       * def registerBehavior(attitude : Behavior) : Behavior
       * &lt;/code&gt;&lt;/pre&gt;
       * This function takes the behavior to be registered, and replies the
       * same behavior.
       * When a behavior is registering, it is receiving the events
       * in the default space of the inner context of the agent, or
       * received by the agent.
       * 
       * @filter(.*) 
       */
      fact "Registering a Behavior"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Behaviors
          import io.sarl.lang.core.Behavior
          behavior B {
          }
          agent A {
            uses Behaviors
            def myaction {
              var b : B
              var c : Behavior
              b = new B(this)
              c = registerBehavior(b)
            }
          }".parsesSuccessfully
      }

      /* Assuming that a behavior was already registered,
       * it is possible for an agent to unregister it: &lt;pre&gt;&lt;code&gt;
       * def unregisterBehavior(attitude : Behavior) : Behavior
       * &lt;/code&gt;&lt;/pre&gt;
       * This function takes the behavior to be registered, and replies the
       * same behavior.
       * When a behavior is unregistering, it is no more receiving the events
       * in the default space of the inner context of the agent, and
       * received by the agent.
       * 
       * @filter(.*) 
       */
      fact "Unregistering a Behavior"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Behaviors
          import io.sarl.lang.core.Behavior
          behavior B {
          }
          agent A {
            uses Behaviors
            def myaction {
              var b : B
              var c : Behavior
              b = new B(this)
              c = unregisterBehavior(b)
            }
          }".parsesSuccessfully
      }

      /* A behavior is executed through its event handlers.
       * Consequently, for running a behavior, it is mandatory
       * to wake it with an event. This particular feature is
       * supported by: &lt;pre&gt;&lt;code&gt;
       * def wake(evt : Event)
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * This function emits the given event into the inner context
       * of the agent (in its default space).
       * 
       * &lt;span class="label label-warning"&gt;Important&lt;/span&gt; It is not
       * possible to execute a particular behavior. All the behaviors
       * waiting for a given event will be executed by this function.
       * 
       * @filter(.*) 
       */
      fact "Executing a Behavior"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Behaviors
          import io.sarl.lang.core.Event
          event E
          agent A {
            uses Behaviors
            def myaction {
              var e : Event
              e = new E
              wake(e)
            }
          }".parsesSuccessfully
      }

      /* Sometimes, it is useful or mandatory for an agent to listen on the
       * events in a given space. The following function permits to
       * retreive the event listener of the agent: &lt;pre&gt;&lt;code&gt;
       * def asEventListener : EventListener
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The listener replied by this function is the one used by the
       * agent (and its behaviors) for listening events related to
       * all the contexts (default, external, and inner).
       * 
       * @filter(.*) 
       */
      fact "Creating an Event Listener"{
        "  package io.sarl.docs.reference.bic
          import io.sarl.core.Behaviors
          import io.sarl.lang.core.EventListener
          agent A {
            uses Behaviors
            def myaction {
              var l : EventListener
              l = asEventListener
            }
          }".parsesSuccessfully
      }

      }

    /* Details on the use of the builtin capacities may be found in the references of
     * the major behavior-based concepts of SARL:&lt;ul&gt;
     * &lt;li&gt;[Agent](AgentReferenceSpec.html)&lt;/li&gt;
     * &lt;li&gt;[Behavior](BehaviorReferenceSpec.html)&lt;/li&gt;
     * &lt;/ul&gt;
     */
    describe "Use of the Builtin Capacities"{
    }
    
}
</pre>
						    </div>
						  </div>
					</div> 
				</div> <!-- /row -->
			</div> <!-- /content -->
		</div> <!-- /tabbable -->
		<footer><p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>
</div> <!-- /container -->

</body>
</html>
