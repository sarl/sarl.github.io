<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<title>Space Reference</title>
<meta name="description" content="">
<meta name="author" content="Jnario">
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><link rel="stylesheet" href="../../../../css/bootstrap.min.css">
<link rel="stylesheet" href="../../../../css/bootstrap-responsive.min.css">
<link rel="stylesheet" href="../../../../css/custom.css">
<link rel="stylesheet" href="../../../../css/prettify.css">
<script type="text/javascript" src="../../../../js/prettify.js"></script><script type="text/javascript" src="../../../../js/lang-jnario.js"></script><script type="text/javascript" src="../../../../js/jquery.js"></script><script type="text/javascript" src="../../../../js/bootstrap-tab.js"></script>
</head>
<body onload="prettyPrint()">
<!-- Fixed navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">SARL</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li class="active"><a href="/">Home</a></li>
        <li><a href="/docs">Documentation</a></li>
        <li><a href="/download">Download</a></li>
        <li><a href="/news">News &amp; Events</a></li>
        <li><a href="/about">About</a></li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
</div>
	<div class="container">
		<div class="tabbable">
			<div class="content">
				<div class="page-header passed">
					<h1>Space Reference</h1>
					  <ul class="nav nav-tabs pull-right">
<li class="active"><a href="#spec" data-toggle="tab">Spec</a></li>
						<li><a href="#source" data-toggle="tab">Source</a></li>
					  </ul>
</div>
				<div class="row">
					<div class="span12">
						  <div class="tab-content">
							  	<div class="tab-pane active" id="spec">
<p>This document describes the features related to the definition of a space in SARL. Before reading this document, it is recommended to read the <a href="./GeneralSyntaxReferenceSpec.html">General Syntax Reference</a>, and the <a href="./AgentReferenceSpec.html">Agent Reference</a>.</p>
<p>One of the key elements that characterize and differentiate the main multiagent approaches is how interactions between agents are described. Some researchers focus on agent-to-agent interactions and corresponding protocols. Within organizational approaches, some consider the organization as a static partition of agents where agents interacts in groups through the roles they play. Others focus on dynamic organizations and normative aspects.</p>
<p>Another essential aspect of the interaction is the interaction Agent-Environment, especially in multiagent-based simulations. Each of these trends of multi-agent systems has led to numerous fruitful and innovative contributions. To remain generic, SARL therefore not imposes a single way of describing the interaction among agents, but rather attempt to provide means to implement each of these approaches.</p>
<p>It is in this perspective that the concepts of <code>Space</code> and <code>SpaceSpecification</code> were defined.</p>
<p>*A Space is the support of the interaction between agents respecting the rules defined in a Space Specification.</p>
<p>*A Space Specification defines the rules (including action and perception) for interacting within a given set of spaces respecting this specification.</p>
<p>SARL natively defines a particular type of <code>Space</code> called <em>Event Space</em> to provide a support to event-driven interactions. Within an event space, agents communicate using events, the <a href="BuiltinCapacityReferenceSpec.html">builtin capacity <code>DefaultContextInteractions</code></a> provides the agent with the means to emit and receive event, respectively using the <code>emit</code> actions and the <code>on</code> keyword in behavior definition. A <em>Default Space</em> is precisely an event space.</p>
<p>Within an event space, the notion of <code>Scope</code> enables to precisely control/filter the potential recipients of an event. *A Scope is a predicate used to filter the potentially called listeners for a given event. The most basic scope is represented by a collection of addresses.</p>
<h3 class="exampleGroup passed" id="Types_of_Spaces">Types of Spaces</h3>
<p>SARL provides a collection of interfaces that are representing different types of spaces.</p>
<ul>
<li>
<p id="Space" class="example passed"><strong>Space</strong></p>
<p>SARL provides a Java interface that is representing all the spaces: </p>
<pre class="prettyprint"> public interface Space {  public SpaceID getID();  public SynchronizedSet<uuid> getParticipants(); } </uuid></pre>
<p>The <code>getID</code> function replies the identifier of the space. The <code>getParticipants</code> function replies the identifiers of the agents belonging to the space.</p>
</li>
<li>
<p id="Event_Space" class="example passed"><strong>Event Space</strong></p>
<p>Spaces that are based on event propagation mechanism are defined as: </p>
<pre class="prettyprint"> public interface EventSpace extends Space {  public Address getAddress(UUID id);  public void emit(Event event, Scope<address> scope);  public void emit(Event event); } </address></pre>
<p>The <code>getAddress</code> function replies the address in the space of the agent that has the given identifier. The <code>emit</code> functions permits to put an event in the space.</p>
</li>
<li>
<p id="Open_Event_Space" class="example passed"><strong>Open Event Space</strong></p>
<p>Event spaces that are allowing to be register inside and unregistezr from are "open event spaces": </p>
<pre class="prettyprint"> public interface OpenEventSpace extends EventSpace {  public Address register(EventListener entity);  public Address unregister(EventListener entity); } </pre>
<p>The functions <code>register</code> and <code>unregister</code> permits to an agent to be involved or not, respectively, in the space.</p>
</li>
<li>
<p id="Restricted_Access_Event_Space" class="example passed"><strong>Restricted Access Event Space</strong></p>
<p>When an event space needs to control the registration access, it should be a: </p>
<pre class="prettyprint"> public interface RestrictedAccessEventSpace extends EventSpace {  public Address register(EventListener entity, Principal requester);  public &lt;P extends EventListener &amp; Principal&gt; Address register(P entity);  public Address unregister(EventListener entity); } </pre>
<p>The functions given by this type of space permits to implement a space with restricted access, based on the standard Java API.</p>
</li>
</ul>
<h3 class="exampleGroup passed" id="Defining_a_Space">Defining a Space</h3>
<p>The definition of a new space must be done with the Java language.</p>
<p>For defining a space, three steps must be followed: </p>
<ol>
<li>Definition of the interface of the space;</li> <li>Implementation of the space on a specific runtime environment;</li> <li>Definition of the space specification.</li> </ol>
<ul>
<li>
<p id="Defining_a_Space" class="example passed"><strong>Defining a Space</strong></p>
<p>The first step for the definition of a new type of space is the specification of the Java interface that is describing the functions provided by the space.</p>
<p>The new space type must extends one of the predefined types. In the following example, the new space is related to the physic environment in which the agents may evolve. This space permits to move an object.</p>
<pre class="prettyprint">
public interface PhysicSpace extends Space {
		public void moveObject(UUID identifier, float x, float y, float z);
}
</pre>
</li>
<li>
<p id="Defining_a_Space_Implementation" class="example passed"><strong>Defining a Space Implementation</strong></p>
<p>The definition of the space implementation depends upon the runtime environment. Below, the implementation extends one of the abstract classes provided by the <a href="http://www.janusproject.io">Janus Platform</a>.</p>
<pre class="prettyprint">
public class PhysicSpaceImpl extends AbstractSpace implements PhysicSpace {
		private Map<uuid> entities = new TreeMap();
		public PhysicSpaceImpl(UUID id) {
			super(id);
		}
		public void moveObject(UUID identifier, float x, float y, float z) {
			PhysicObject o = this.entities.get(identifier);
			if (identifier!=null) {
				o.move(x, y, z);
			}
		}
}
</uuid></pre>
</li>
<li>
<p id="Defining_a_SpaceSpecification" class="example passed"><strong>Defining a SpaceSpecification</strong></p>
<p>For creating instances of spaces, it is necessary to define a space specification.</p>
<pre class="prettyprint">
public class PhysicSpaceSpecification implements SpaceSpecification<physicspace> {
		public PhysicSpace create(SpaceID id, Object... params) {
			return new PhysicSpace(id);
		}
}
</physicspace></pre>
</li>
</ul>
</div>
						    <div class="tab-pane" id="source">
						    	<h3>Space.spec</h3>
						    	<p>
</p>
<pre class="prettyprint lang-spec linenums">
/*
 * Copyright 2014 Sebastian RODRIGUEZ, Nicolas GAUD, St√©phane GALLAND
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.docs.reference

import static org.junit.Assert.*;
import io.sarl.docs.utils.SARLSpecCreator
import org.jnario.runner.CreateWith
import io.sarl.lang.core.Space
import io.sarl.lang.core.EventSpace
import java.util.UUID
import io.sarl.lang.core.Event
import io.sarl.lang.core.Scope
import io.sarl.util.OpenEventSpace
import io.sarl.lang.core.EventListener
import io.sarl.util.RestrictedAccessEventSpace
import java.security.Principal

/**
 * This document describes the features related to the definition of a space in SARL.
 * Before reading this document, it is recommended to read
 * the [General Syntax Reference](./GeneralSyntaxReferenceSpec.html),
 * and the [Agent Reference](./AgentReferenceSpec.html).
 * 
 * One of the key elements that characterize and differentiate the main 
 * multiagent approaches is how interactions between agents are described.
 * Some researchers focus on agent-to-agent interactions and corresponding 
 * protocols. Within organizational approaches, some consider the 
 * organization as a static partition of agents where agents interacts in 
 * groups through the roles they play. Others focus on dynamic 
 * organizations and normative aspects. 
 * 
 * Another essential aspect of the interaction is the interaction 
 * Agent-Environment, especially in multiagent-based simulations.
 * Each of these trends of multi-agent systems has led to numerous 
 * fruitful and innovative contributions.
 * To remain generic, SARL therefore not imposes a single way of 
 * describing the interaction among agents, but rather attempt to 
 * provide means to implement each of these approaches.
 * 
 * It is in this perspective that the concepts of &lt;code&gt;Space&lt;/code&gt;
 * and &lt;code&gt;SpaceSpecification&lt;/code&gt; were defined.
 * 
 * *A Space is the support of the interaction between agents respecting 
 * the rules defined in a Space Specification.*
 * 
 * *A Space Specification defines the rules (including action and
 * perception) for interacting within a given set of spaces respecting 
 * this specification.*
 * 
 * SARL natively defines a particular type of &lt;code&gt;Space&lt;/code&gt; called
 * *Event Space* to provide a support to event-driven interactions.
 * Within an event space, agents communicate using events, the 
 * [builtin capacity &lt;code&gt;DefaultContextInteractions&lt;/code&gt;](BuiltinCapacityReferenceSpec.html)
 * provides the agent with the means to emit and receive event, respectively 
 * using the &lt;code&gt;emit&lt;/code&gt; actions and the &lt;code&gt;on&lt;/code&gt; keyword
 * in behavior definition.
 * A *Default Space* is precisely an event space.
 * 
 * Within an event space, the notion of &lt;code&gt;Scope&lt;/code&gt; enables to 
 * precisely control/filter the potential recipients of an event.
 * *A Scope is a predicate used to filter the potentially called 
 * listeners for a given event.*
 * The most basic scope is represented by a collection of addresses.
 */
@CreateWith(SARLSpecCreator)
describe "Space Reference" {
  
    def Class&lt;?&gt; mustHaveMethod(Class&lt;?&gt; type, String name, Class&lt;?&gt;... parameters) {
      try {
        var m = type.getDeclaredMethod(name, parameters)
        assertNotNull("Missed "+name+" function in "+type.simpleName, m);
      } catch( Throwable e ) {
        fail("Missed "+name+" function in "+type.simpleName)
      }
      return type
    }
  
    def Class&lt;?&gt; mustHaveField(Class&lt;?&gt; type, String fieldName, String fieldType) {
      try {
        var f = type.getDeclaredField(fieldName)
        assertNotNull("Missed "+fieldName+" field in "+type.simpleName, f);
        assertEquals("Invalid field type", fieldType, f.type.name)
      } catch( Throwable e ) {
        fail("Missed "+fieldName+" field in "+type.simpleName);
      }
      return type
    }

    def Class&lt;?&gt; mustHaveFeatures(Class&lt;?&gt; type, int numberOfMethods, int numberOfFields) {
      assertEquals("Invalid number of declared methods", numberOfMethods, type.declaredMethods.length)
      assertEquals("Invalid number of declared fields", numberOfFields, type.declaredFields.length)
      return type
    }

    def Class&lt;?&gt; mustExtend(Class&lt;?&gt; type, String supertype) {
      if (type.interface) {
        if (supertype===null) {
          assertEquals("Invalid super-type", 0, type.interfaces.length)
        }
        else {
          var found = false
          for(t : type.interfaces) {
            if (t.name==supertype) {
              found = true
            }
          }
          if (!found) {
            fail("Invalid super-type. Expected: "+supertype)
          }
        }
      }
      else {
        if (supertype===null) {
          assertNull("Invalid super-type", type.superclass)
        }
        else {
          assertNotNull("Invalid super-type", type.superclass)
          assertEquals("Invalid super-type", supertype, type.superclass.name)
        }
      }
      return type
    }

    /* SARL provides a collection of interfaces that are representing different
     * types of spaces.
     */  
    describe "Types of Spaces" {
      
      /* SARL provides a Java interface that is representing all
       * the spaces: &lt;pre&gt;&lt;code&gt;
       * public interface Space {
       *     public SpaceID getID();
       *     public SynchronizedSet&lt;UUID&gt; getParticipants();
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The &lt;code&gt;getID&lt;/code&gt; function replies the identifier of the space.
       * The &lt;code&gt;getParticipants&lt;/code&gt; function replies the identifiers
       * of the agents belonging to the space.
       *  
       * @filter(.*) 
       */
      fact "Space" {
        Space.mustExtend(null)
        Space.mustHaveFeatures(2, 0)
        Space.mustHaveMethod("getID")
        Space.mustHaveMethod("getParticipants")
      }
      
      /* Spaces that are based on event propagation mechanism are defined
       * as: &lt;pre&gt;&lt;code&gt;
       * public interface EventSpace extends Space {
       *     public Address getAddress(UUID id);
       *     public void emit(Event event, Scope&lt;Address&gt; scope);
       *     public void emit(Event event);
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The &lt;code&gt;getAddress&lt;/code&gt; function replies the address in the space
       * of the agent that has the given identifier.
       * The &lt;code&gt;emit&lt;/code&gt; functions permits to put an event in
       * the space.
       *  
       * @filter(.*) 
       */
      fact "Event Space" {
        EventSpace.mustExtend("io.sarl.lang.core.Space")
        EventSpace.mustHaveFeatures(3, 0)
        EventSpace.mustHaveMethod("getAddress", UUID)
        EventSpace.mustHaveMethod("emit", Event, Scope)
        EventSpace.mustHaveMethod("emit", Event)
      }

      /* Event spaces that are allowing to be register inside and
       * unregistezr from are "open event spaces": &lt;pre&gt;&lt;code&gt;
       * public interface OpenEventSpace extends EventSpace {
       *     public Address register(EventListener entity);
       *     public Address unregister(EventListener entity);
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The functions &lt;code&gt;register&lt;/code&gt; and &lt;code&gt;unregister&lt;/code&gt;
       * permits to an agent to be involved or not, respectively,
       * in the space.
       *  
       * @filter(.*) 
       */
      fact "Open Event Space" {
        OpenEventSpace.mustExtend("io.sarl.lang.core.EventSpace")
        OpenEventSpace.mustHaveFeatures(2, 0)
        OpenEventSpace.mustHaveMethod("register", EventListener)
        OpenEventSpace.mustHaveMethod("unregister", EventListener)
      }

      /* When an event space needs to control the registration access,
       * it should be a: &lt;pre&gt;&lt;code&gt;
       * public interface RestrictedAccessEventSpace extends EventSpace {
       *     public Address register(EventListener entity, Principal requester);
       *     public &lt;P extends EventListener &amp; Principal&gt; Address register(P entity);
       *     public Address unregister(EventListener entity);
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * The functions given by this type of space permits to implement
       * a space with restricted access, based on the standard Java API.
       *  
       * @filter(.*) 
       */
      fact "Restricted Access Event Space" {
        RestrictedAccessEventSpace.mustExtend("io.sarl.lang.core.EventSpace")
        RestrictedAccessEventSpace.mustHaveFeatures(3, 0)
        RestrictedAccessEventSpace.mustHaveMethod("register", EventListener, Principal)
        RestrictedAccessEventSpace.mustHaveMethod("register", EventListener)
        RestrictedAccessEventSpace.mustHaveMethod("unregister", EventListener)
      }

    }
  
    /* The definition of a new space must be done with
     * the Java language.
     * 
     * For defining a space, three steps must be followed: &lt;ol&gt;
     * &lt;li&gt;Definition of the interface of the space;&lt;/li&gt;
     * &lt;li&gt;Implementation of the space on a specific runtime environment;&lt;/li&gt;
     * &lt;li&gt;Definition of the space specification.&lt;/li&gt;
     * &lt;/ol&gt;
     */
    describe "Defining a Space" {

      /* The first step for the definition of a new type of space is
       * the specification of the Java interface that is describing
       * the functions provided by the space.
       * 
       * The new space type must extends one of the predefined types.
       * In the following example, the new space is related to
       * the physic environment in which the agents may evolve.
       * This space permits to move an object.
       * 
       * &lt;pre&gt;&lt;code&gt;
       * public interface PhysicSpace extends Space {
       *     public void moveObject(UUID identifier, float x, float y, float z);
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * @filter(.*) 
       */
      fact "Defining a Space"{
        "no check"
      }
      
      /* The definition of the space implementation depends upon
       * the runtime environment. Below, the implementation
       * extends one of the abstract classes provided by the
       * [Janus Platform](http://www.janusproject.io).
       * 
       * &lt;pre&gt;&lt;code&gt;
       * public class PhysicSpaceImpl extends AbstractSpace implements PhysicSpace {
       *     private Map&lt;UUID,PhysicObject&gt; entities = new TreeMap&lt;&gt;();
       *     public PhysicSpaceImpl(UUID id) {
       *       super(id);
       *     }
       *     public void moveObject(UUID identifier, float x, float y, float z) {
       *       PhysicObject o = this.entities.get(identifier);
       *       if (identifier!=null) {
       *         o.move(x, y, z);
       *       }
       *     }
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * @filter(.*) 
       */
      fact "Defining a Space Implementation"{
        "no check"
      }

      /* For creating instances of spaces, it is necessary to define
       * a space specification.
       * 
       * &lt;pre&gt;&lt;code&gt;
       * public class PhysicSpaceSpecification implements SpaceSpecification&lt;PhysicSpace&gt; {
       *     public PhysicSpace create(SpaceID id, Object... params) {
       *       return new PhysicSpace(id);
       *     }
       * }
       * &lt;/code&gt;&lt;/pre&gt;
       * 
       * @filter(.*) 
       */
      fact "Defining a SpaceSpecification"{
        "no check"
      }

    }
  
}
</pre>
						    </div>
						  </div>
					</div> 
				</div> <!-- /row -->
			</div> <!-- /content -->
		</div> <!-- /tabbable -->
		<footer><p><small>Generated by <a href="http://www.jnario.org">Jnario</a>.</small></p>
		</footer>
</div> <!-- /container -->

</body>
</html>
