<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="SARL is a general-purpose agent-oriented language.
SARL aims at providing the fundamental abstractions for dealing with concurrency, distribution, interaction, decentralization, reactivity, autonomy and dynamic reconfiguration. These high-level features are now considered as the major requirements for an easy and practical implementation of modern complex software applications. We are convinced that the agent-oriented paradigm holds the keys to effectively meet this challenge.
Considering the variety of existing approaches and meta-models in the field of agent-oriented engineering and more generally multi-agent systems, our approach remains as generic as possible and highly extensible to easily integrate new concepts and features. The language is platform- and architecture-independent.
">
    <meta name="author" content="SARL Team">
    <link rel="icon" href="../../../images/favicon.ico" />
    <link rel="shortcut icon" href="../../../images/favicon.ico">

    <title>Creating a SARL Run-time Environment for the tinyMAS platform</title>

    <link rel="stylesheet" href="../../../css/bootstrap.min.css">
    <link rel="stylesheet" href="../../../css/font-awesome.min.css">
    <link rel="stylesheet" href="../../../css/pygments.css">
    <link rel="stylesheet" href="../../../css/custom.css">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>

    

<!-- Fixed navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://www.sarl.io">SARL</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="../../../index.html">Home</a></li>
        <li><a href="../../../docs/index.html">Documentation</a></li>
        <li><a href="../../../download/index.html">Download</a></li>
        <li><a href="../../../runtime/index.html">Run-time</a></li>
        <li><a href="../../../community/index.html">Community</a></li>
        <li><a href="../../../news/index.html">News &amp; Events</a></li>
        <li><a href="../../../publications/index.html">Publications &amp; Presentations</a></li>
        <li><a href="../../../about/index.html">About</a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</div>

    <div class="container">
		
		<a href="https://github.com/sarl/sarl" target="_blank"><img
			style="position: absolute; top: 40px; right: 0; border: 0;"
			src="https://github-camo.global.ssl.fastly.net/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" 
			alt="Fork me on GitHub"
			data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>
		
      <h1 id="creating-a-sarl-run-time-environment-for-the-tinymas-platform">Creating a SARL Run-time Environment for the tinyMAS platform</h1>

<ul class="page_outline" id="page_outline">

<li><a href="#1-sarl-and-tinymas-metamodels">1. SARL and tinyMAS metamodels</a></li>
<ul>
  <li><a href="#1-1-sarl-metamodel">1.1. SARL Metamodel</a></li>
  <li><a href="#1-2-tinymas-metamodel">1.2. TinyMAS Metamodel</a></li>
  <li><a href="#1-3-linking-the-metamodels-concepts">1.3. Linking the metamodels' concepts</a></li>
</ul>

<p><li><a href="#2-mapping-of-the-identifiers">2. Mapping of the identifiers</a></li>
<li><a href="#3-definition-of-the-default-context">3. Definition of the default context</a></li>
<ul>
  <li><a href="#3-1-definition-of-the-context-class">3.1. Definition of the context class</a></li>
  <li><a href="#3-2-definition-of-the-context-identifier">3.2. Definition of the context identifier</a></li>
  <li><a href="#3-3-declaration-of-the-default-space-of-the-context">3.3. Declaration of the default space of the context</a></li>
  <li><a href="#3-4-definition-of-the-getter-functions-for-spaces">3.4. Definition of the getter functions for spaces</a></li>
  <li><a href="#3-5-definition-of-the-default-space">3.5. Definition of the default space</a></li>
</ul>
<li><a href="#4-first-definition-of-the-agent">4. First definition of the agent</a></li>
<ul>
  <li><a href="#4-1-sarl-agent-inside-tinymas-agent">4.1. SARL Agent inside tinyMAS Agent</a></li>
  <li><a href="#4-2-firing-sarl-events">4.2. Firing SARL events</a></li>
  <li><a href="#4-3-registering-the-sarl-agent-as-behavior-unit-provider">4.3. Registering the SARL agent as behavior unit provider</a></li>
  <li><a href="#4-4-receiving-sarl-events">4.4. Receiving SARL events</a></li>
  <li><a href="#4-5-initialize-and-destroy-events">4.5. Initialize and Destroy events</a></li>
</ul>
<li><a href="#5-tool-for-spawning-agents">5. Tool for spawning agents</a></li>
<ul>
  <li><a href="#5-1-creating-a-tinymas-agent-from-a-sarl-agent">5.1. Creating a tinyMAS agent from a SARL agent</a></li>
  <li><a href="#5-2-launching-a-tinymas-sarl-agent-on-the-tinymas-kernel">5.2. Launching a tinyMAS-SARL agent on the tinyMAS kernel</a></li>
  <li><a href="#5-3-general-utility-function-for-spawning-agents">5.3. General utility function for spawning agents</a></li>
</ul>
<li><a href="#6-definition-of-the-built-in-capacities">6. Definition of the built-in capacities</a></li>
<ul>
  <li><a href="#6-1-definition-of-the-logging-skill">6.1. Definition of the Logging skill</a></li>
  <li><a href="#6-2-definition-of-the-lifecycle-skill">6.2. Definition of the Lifecycle skill</a></li>
  <li><a href="#6-3-definition-of-the-defaultcontextinteractions-skill">6.3. Definition of the DefaultContextInteractions skill</a></li>
  <li><a href="#6-4-definition-of-the-behaviors-skill">6.4. Definition of the Behaviors skill</a></li>
  <li><a href="#6-5-definition-of-the-schedules-skill">6.5. Definition of the Schedules skill</a></li>
  <li><a href="#6-6-definition-of-the-time-skill">6.6. Definition of the Time skill</a></li>
  <li><a href="#6-7-definition-of-the-externalcontextaccess-and-innercontextaccess-skills">6.7. Definition of the ExternalContextAccess and InnerContextAccess skills</a></li>
</ul>
<li><a href="#7-creating-built-in-capacity-instances-in-the-agent">7. Creating built-in capacity instances in the agent</a></li>
<ul>
  <li><a href="#7-1-storing-the-built-in-capacities-in-agent-fields">7.1. Storing the built-in capacities in agent fields</a></li>
  <li><a href="#7-2-initializing-the-agent-built-in-capacities">7.2. Initializing the agent built-in capacities</a></li>
  <li><a href="#7-3-uninstalling-the-agent-built-in-capacities">7.3. Uninstalling the agent built-in capacities</a></li>
</ul>
<li><a href="#8-from-the-tinymas-proactive-message-ready-to-the-sarl-reactive-event-handling">8. From the tinyMAS proactive message ready to the SARL reactive event handling</a></li>
<li><a href="#9-booting-infrastructure">9. Booting infrastructure</a></li>
<ul>
  <li><a href="#9-1-definition-of-the-main-entry-point">9.1. Definition of the main entry point</a></li>
  <li><a href="#9-2-creation-of-the-sarl-default-context-and-space-instances">9.2. Creation of the SARL default context and space instances</a></li>
  <li><a href="#9-3-management-of-the-command-line-parameters">9.3. Management of the command-line parameters</a></li>
  <li><a href="#9-4-launching">9.4. Launching</a></li>
</ul>
<li><a href="#10-general-events">10. General Events</a></li>
<li><a href="#11-finalizing-the-agent-spawning">11. Finalizing the agent spawning</a></li>
<li><a href="#12-update-of-the-jar-manifest-for-making-the-archive-as-a-sre">12. Update of the Jar Manifest for making the archive as a SRE</a></li>
<ul>
  <li><a href="#12-1-definition-of-the-configuration-elements">12.1. Definition of the configuration elements</a></li>
  <li><a href="#12-2-how-to-update-the-jar-manifest-by-hand">12.2. How to update the Jar Manifest by hand</a></li>
  <li><a href="#12-3-maven-plugin-for-updating-the-manifest">12.3. Maven Plugin for Updating the Manifest</a></li>
</ul>
<li><a href="#13-configuration-of-a-sre-bootstrap">13. Configuration of a SRE Bootstrap</a></li>
<ul>
  <li><a href="#13-1-configuration-by-hand">13.1. Configuration by hand</a></li>
  <li><a href="#13-2-configuration-with-maven-plugin">13.2. Configuration with Maven plugin</a></li>
</ul>
<li><a href="#14-legal-notice">14. Legal Notice</a></li></p>

<p></ul></p>

<p>This document describes how to create a SARL Run-time Environment (SRE) with the
<a href="https://github.com/gallandarakhneorg/tinymas">tinyMAS platform</a>.</p>

<p>SRE executes or interprets compiled SARL code on an &quot;hardware platform.&quot;
The figure below illustrates the compilation process of a SARL program in which the
run-time environment is involved.</p>

<p><img src="../compilation/compilation_process.png" alt="SARL Generation Process"></p>

<p>The Tiny Multiagent Platform (tinyMAS) is a very small software platform, which permits to implement
and run agent-based systems. This platform was written by St&eacute;phane GALLAND and Nicolas GAUD for the
multiagent courses of the Computer Science Department of the
<a href="http://www.utbm.fr">Belfort-Montb&eacute;liard University of Technology</a>.</p>

<p>The purpose of this document is to describe the basics steps for making a SRE without
changing the source code of neither the platform nor the SARL compiler.
The tinyMAS SRE does not support all the elements of the SARL metamodel. Indeed the support for
external contexts and inner contexts is not implemented.</p>

<p>Before reading this document, it is recommended reading the
<a href="../reference/GeneralSyntax.html">General Syntax Reference</a>.</p>

<div class="bt-download">
<a href="https://github.com/gallandarakhneorg/tinymas"><img alt="See the source" src="http://www.sarl.io/images/download-icon.png"/></a>
</div>

<p>The elements that are explained in this tutorial are:</p>

<ul>
<li>the definition of the concepts from the SARL metamodel linked to the tinyMAS concepts;</li>
<li>the definition of the definition of the boot process;</li>
<li>the update of the manifest in order to make tinyMAS recognized as a SRE.</li>
</ul>

<p>The source code related to this tutorial may be found in the
<a href="https://github.com/gallandarakhneorg/tinymas">tinyMAS Git repository</a>.</p>

<h2 id="1-sarl-and-tinymas-metamodels">1. SARL and tinyMAS metamodels</h2>

<p>The SARL language and the tinyMAS platform have been defined based on a collection
of concepts that are formally described in their respective metamodels.
This section gives a short overview of the two metamodels, and their possible links.</p>

<p>Defining the links between the SARL metamodel and the metamodel of the SRE is the first
mandatory point for transforming the targeted platform to SRE.</p>

<h3 id="1-1-sarl-metamodel">1.1. SARL Metamodel</h3>

<p>The SARL language is based on a collection of concepts that are described into its metamodel.</p>

<p><img src="./SARL_metamodel.png" alt="Part of the SARL Metamodel"></p>

<p>The key elements in the SARL metamodel are:</p>

<ul>
<li><code class="prettyprint">Context</code>: defines a set of interaction spaces in which agents are involved.</li>
<li><code class="prettyprint">Space</code>: or interaction space; defines a space in which interactions may occur.</li>
<li><code class="prettyprint">Address</code>: defines the identifiers of the agents in the interaction spaces.</li>
<li><code class="prettyprint">EventSpace</code>: defines a specific interaction space in which agents are interacting by firing and receiving events.</li>
<li><code class="prettyprint">Event</code>: defines an information/event that is exchanged by agents in an event space.</li>
<li><code class="prettyprint">Capacity</code>: defines a know-how of the agent; actions defines in a capacity could be invoked by the agent.</li>
<li><code class="prettyprint">Skill</code>: defines a specific implementation of a capacity. When a capacity&#39;s action is invoked by an agent, the corresponding implementation in the skill is called.</li>
<li><code class="prettyprint">Behavior</code>: defines a sub-part of the agent&#39;s behavior.</li>
<li>Built-in capacities: the capacities that are known by the agents by default. The corresponding skills are provided by the run-time environment.</li>
</ul>

<h3 id="1-2-tinymas-metamodel">1.2. TinyMAS Metamodel</h3>

<p>The tinyMAS platform is based on a collection of concepts that are described into its metamodel.</p>

<p><img src="./tinyMAS_metamodel.png" alt="Part of the tinyMAS Metamodel"></p>

<p>The key elements in the tinyMAS metamodel are:</p>

<ul>
<li><code class="prettyprint">AgentIdentifier</code>: defines the identifiers of the agents.</li>
<li><code class="prettyprint">Agent</code>: defines the concept of agent. Application agents must be defined in sub-classes.</li>
<li><code class="prettyprint">Message</code>: defines the base information exchanged by the agents.</li>
<li><code class="prettyprint">MessageTransportService</code> (and <code class="prettyprint">AgentCommunicationChannel</code>): define the routing mechanism for the messages.</li>
<li><code class="prettyprint">MailboxManager</code>: defines a container of received messages for each agent.</li>
<li><code class="prettyprint">WhitePages</code>: defines a repository of all the agents in the system. It maps the agent identifiers to the agents.</li>
<li><code class="prettyprint">YellowPages</code>: defines a repository of services that could be provided by the agents. It maps the name of a service to a list of agent identifiers.</li>
<li><code class="prettyprint">Scheduler</code>: defines the agent execution policy.</li>
<li><code class="prettyprint">Kernel</code>: represents the entire tinyMAS platform. </li>
<li><code class="prettyprint">KernelListener</code>: describes an object that could be notified when a specific event occured in the tinyMAS kernel. </li>
</ul>

<h3 id="1-3-linking-the-metamodels-concepts">1.3. Linking the metamodels&#39; concepts</h3>

<p>The elements to define for creating a SRE are described in the following table.
This table provides the mapping of these elements (several SARL concepts) to
the corresponding implementation approach for tinyMAS.</p>

<p>The first column of the table gives the key point to consider for creating a SRE.
The second column provides the key SARL concepts.
And the third column describes the basics of the implementation for tinyMAS.</p>

<table><thead>
<tr>
<th>SARL Element</th>
<th>SARL Concept</th>
<th>tinyMAS Implementation</th>
</tr>
</thead><tbody>
<tr>
<td>Identifying the agents</td>
<td><code class="prettyprint">Address</code></td>
<td>tinyMAS provides the concept of <code class="prettyprint">AgentIdentifier</code>. This identifier contains a reference to the kernel identifier, and the UUID of the agent. The SARL Address is for a specific interaction space. It contains the space identifier, and the UUID of the agent. For making the implementation simple, we assume that there is only the SARL default space available. The other spaces will not be supported by a tinyMAS implementation.</td>
</tr>
<tr>
<td>Agent abstraction</td>
<td><code class="prettyprint">Agent</code></td>
<td>A specific implementation of the tinyMAS <code class="prettyprint">Agent</code> should be coded. This implementation must have a reference to the SARL <code class="prettyprint">Agent</code>. Additionally, the tinyMAS <code class="prettyprint">Agent</code> will be the place to write the support for the agent life-cycle and the built-in capacities.</td>
</tr>
<tr>
<td>Exchanged information format for direct interaction</td>
<td><code class="prettyprint">Event</code></td>
<td>The interaction in the tinyMAS platform is based on the concept of <code class="prettyprint">Message</code>. tinyMAS provides all the features for routing and delivering the messages. Because the SARL agents are exchanging events by default, the tinyMAS cannot be directly delivered to the SARL agents. Linking the <code class="prettyprint">Message</code> and <code class="prettyprint">Event</code> concepts is done by considering that each <code class="prettyprint">Event</code> occurrence must be enveloped by a <code class="prettyprint">Message</code>, i.e. the content of a tinyMAS message is a SARL event.</td>
</tr>
<tr>
<td>Receiving SARL events</td>
<td>Behavior units <code class="prettyprint">on</code></td>
<td>A specific module in tinyMAS must be written for invoking the SARL behavior units on each SARL event that are in the received tinyMAS messages.</td>
</tr>
<tr>
<td>Default context definition</td>
<td><code class="prettyprint">Context</code></td>
<td>In SARL, every agent exists in a context, named the default context. It is mandatory for tinyMAS to provide an implementation for the default context.</td>
</tr>
<tr>
<td>Default space definition</td>
<td><code class="prettyprint">EventSpace</code></td>
<td>In SARL, every agent could interact through the default interaction space. It is mandatory for tinyMAS to provide an implementation for the default space.</td>
</tr>
<tr>
<td>Agent life-cycle</td>
<td></td>
<td>The agent life-cycle in tinyMAS is based on the calls to the functions <code class="prettyprint">start</code> for initialization, <code class="prettyprint">live</code> for running the agent behavior, and <code class="prettyprint">end</code> for destroying the agent. The agent life-cycle in SARL is different. It is based on the receiving of events. The <code class="prettyprint">Initialize</code> event represents the initialization of the agent. The <code class="prettyprint">Destroy</code> event represents the agent destruction. The other events enable to create the agent behavior. Because the tinyMAS agent is the one that will be executed by tinyMAS, it is mandatory to generates the SARL events in the three tinyMAS life-cycle functions, a.k.a. <code class="prettyprint">start</code>, <code class="prettyprint">live</code>, <code class="prettyprint">end</code>.</td>
</tr>
<tr>
<td>Managing platform events</td>
<td><code class="prettyprint">AgentSpawned</code>, <code class="prettyprint">AgentKilled</code></td>
<td>Several SARL events are assumed to be fired by the SRE. The two events that will be supported by tinyMAS are <code class="prettyprint">AgentSpawned</code> for agent spawning, and <code class="prettyprint">AgentKilled</code> for agent destruction. The other SARL platform events are ignored by tinyMAS, e.g. <code class="prettyprint">ContextJoined</code>, <code class="prettyprint">ContextLeft</code>, <code class="prettyprint">MemberJoined</code>, <code class="prettyprint">MemberLeft</code>.</td>
</tr>
<tr>
<td>Agent Spawning</td>
<td><code class="prettyprint">spawn</code> functions</td>
<td>A specific agent spawning function must be written for creating a tinyMAS agent that is embedding a SARL agent definition. This spawning functions will be invoked by the built-in capacities (see below).</td>
</tr>
<tr>
<td>Built-in capacity implementation</td>
<td><a href="../reference/BIC.html">BICs</a></td>
<td>It is assumed that every SARL agent always contains the skills for a specific set of capacities, named the built-in capacities. These skills are supposed to be provided by the SRE. Consequently, each built-in capacity must have an implementation based on the tinyMAS features.</td>
</tr>
<tr>
<td></td>
<td>SRE Booting</td>
<td></td>
</tr>
</tbody></table>

<h2 id="2-mapping-of-the-identifiers">2. Mapping of the identifiers</h2>

<p><code class="prettyprint">AgentIdentifier</code> in tinyMAS is based on a UUID and a reference to the identifier of the kernel.
Because <code class="prettyprint">AgentIdentifier</code> does not provide a function for retrieving the UUID, we
should write an utility class for obtaining it.</p>

<p>The <code class="prettyprint">AgentIdentifier</code> string representation contains the UUID, followed by a column character
and the kernel identifier.</p>

<p>This utility class will be used for extracting the UUID of the tinyMAS agent identifier
in order to create SARL address on the fly.</p>

<div class="highlight highlight-SARL"><pre>
final class Identifiers {

    static def toUUID(aid : AgentIdentifier) : UUID {
        val aidstr = aid.toString
        val index = aidstr.indexOf(":")
        return UUID::fromString(aidstr.substring(0, index))
    }

}
</pre></div>

<h2 id="3-definition-of-the-default-context">3. Definition of the default context</h2>

<p>A SARL Context defines the boundary of a sub-system, and gathers a collection of interaction Spaces.
In each context, there is at least one particular space called the default space to which all agents in this
context belong. This ensures the existence of a common shared space to all agents in the same context.</p>

<p>Each agent can then create specific public or private spaces to achieve its personal goals.
Since their creation, agents are incorporated into a context called the default context.</p>

<p>The concept of context is not explicit in tinyMAS, i.e. all agents are evolving in the same and unique
context.</p>

<p>Because SARL agents require to have access to the instance of the default context, a specific
implementation must be provided upon the tinyMAS API.</p>

<h3 id="3-1-definition-of-the-context-class">3.1. Definition of the context class</h3>

<p>A SARL context must be a class that is implementing the <code class="prettyprint">AgentContext</code> type (provided in the SARL API).</p>

<div class="highlight highlight-SARL"><pre>
class TMAgentContext implements io.sarl.lang.core.AgentContext {
    // The code in the rest of this section will appear here
}
</pre></div>

<h3 id="3-2-definition-of-the-context-identifier">3.2. Definition of the context identifier</h3>

<p>A SARL context must have a unique identifier.
We assume that only one context, the default context, will exist in
the SARL applications ran with tinyMAS.</p>

<p>In order to retrieve easy the UUID of the default (root) context,
we define the identifier as a public constant.</p>

<div class="highlight highlight-SARL"><pre>
public static val TINYMAS_AGENT_CONTEXT_ID = UUID::fromString("cdb0d568-4059-40cf-96c4-d078fee91cb1")
def getID : UUID {
    TINYMAS_AGENT_CONTEXT_ID
}
</pre></div>

<h3 id="3-3-declaration-of-the-default-space-of-the-context">3.3. Declaration of the default space of the context</h3>

<p>A SARL context has a default interaction space.</p>

<p>We declare the default space in the context class <code class="prettyprint">TMAgentContext</code>.
The concrete definition of the default space class named <code class="prettyprint">TMDefaultSpace</code> is done later in this document.</p>

<div class="highlight highlight-SARL"><pre>
var defaultSpace : TMDefaultSpace
def getDefaultSpace : EventSpace {
    this.defaultSpace
}
</pre></div>

<h3 id="3-4-definition-of-the-getter-functions-for-spaces">3.4. Definition of the getter functions for spaces</h3>

<p>A SARL context provides a collection of functions for retrieving the spaces inside the context.</p>

<p>Please note that we assume that only one context will exist in the tinyMAS application.
This context will be assumed to be the default context.
In the same way, we assume that only one space (the default space) will exist in the default
context.</p>

<p>Consequently, the function <code class="prettyprint">getSpace()</code> replies the collection of all the context as
an singleton collection instance that is containing the default space.
This function must reply a auto-synchronized collection. We use the <code class="prettyprint">Collections3</code> utility
class, provided in the SARL API, for creating the synchronized collection.
The first parameter of the <code class="prettyprint">synchronizedCollection</code> function is the collection to synchronized,
the second parameter is the object on from which the synchronization token will be obtained.</p>

<p>The <code class="prettyprint">getSpace(Class)</code> function is supposed to reply the existing spaces that were created
by using the given type of space specification.
Because of our assumption on the space singleton in the context, this function replies
only the default space if the given space specification type is <code class="prettyprint">EventSpaceSpecification</code>.</p>

<p>The <code class="prettyprint">getSpace(UUID)</code> function replies the default space only if the given UUID is the
identifier of the default space. In the other cases, the function replies nothing.</p>

<div class="highlight highlight-SARL"><pre>
def getSpaces : SynchronizedCollection<? extends Space> {
    Collections3::synchronizedCollection(Collections::singleton(this.defaultSpace), this)
}
def getSpaces(spec : Class<? extends SpaceSpecification<S>>)
        : SynchronizedCollection<S>
        with S extends Space {
    if (spec !== null && spec == typeof(EventSpaceSpecification)) {
        return Collections3::synchronizedCollection(Collections::singleton(this.defaultSpace as S), this);
    }
    return Collections3::synchronizedCollection(Collections::emptyList, this)
}
def getSpace(spaceUUID : UUID) : S
        with S extends Space {
    if (spaceUUID == this.defaultSpace.spaceID.ID) {
        return this.defaultSpace as S
    }
    return null
}
</pre></div>

<h4 id="definition-of-the-creation-functions-for-spaces">Definition of the creation functions for spaces</h4>

<p>The context provides functions for creating spaces. Because we assume that no additional space could be created upon the tinyMAS
SRE implementation, all these functions generates an &quot;unsupported operation&quot; exception.</p>

<div class="highlight highlight-SARL"><pre>
def createSpace(spec : Class<? extends SpaceSpecification<S>>,
        spaceUUID : UUID, creationParams : Object*)
        : S
        with S extends Space {
    throw new UnsupportedOperationException
}
def getOrCreateSpaceWithSpec(spec : Class<? extends SpaceSpecification<S>>,
        spaceUUID : UUID,creationParams : Object*)
        : S
        with S extends Space {
    throw new UnsupportedOperationException
}
def getOrCreateSpaceWithID(spaceUUID : UUID,
        spec : Class<? extends SpaceSpecification<S>>,
        creationParams : Object*)
        : S
        with S extends Space {
    throw new UnsupportedOperationException
}
</pre></div>

<h4 id="definition-of-the-constructor">Definition of the constructor</h4>

<p>The constructor of the agent context class must be defined for initializing the fields of the class.</p>

<p>The instance of the default space must be provided as parameter in order to set the <code class="prettyprint">defaultSpace</code> field.</p>

<p>Additionally, the default space instance must be linked to the context (see the definition of the space
class below). In the constructor, the <code class="prettyprint">setAgentContext</code> is invoked on the default space. </p>

<div class="highlight highlight-SARL"><pre>
new (defaultSpace : TMDefaultSpace) {
    this.defaultSpace = defaultSpace
    this.defaultSpace.setAgentContext(this);
}
</pre></div>

<h3 id="3-5-definition-of-the-default-space">3.5. Definition of the default space</h3>

<p>The default space is the interaction space in which all the agents will be involved.
Because we assume that only one agent context exists in the system, the default space
becomes a singleton (only one default space could exist in a context).</p>

<h4 id="definition-of-the-space-class">Definition of the space class</h4>

<p>A SARL default space must support an event-based interaction mechanism.
Consequently, the default space class must implement the <code class="prettyprint">EventSpace</code> interface
that is provided by the SARL API.</p>

<div class="highlight highlight-SARL"><pre>
class TMDefaultSpace implements io.sarl.lang.core.EventSpace {
    // The code in the rest of this section will appear here
}
</pre></div>

<h4 id="definition-of-the-context-identifier">Definition of the context identifier</h4>

<p>A SARL space must have a unique identifier. We assume that only one context, the default context, will exist in
the SARL applications ran with tinyMAS. Consequently, the default space instance becomes a singleton.</p>

<p>In order to retrieve easy the UUID of the default (root) context, we define the identifier as a public constant.</p>

<p>We defines the function <code class="prettyprint">getSpaceID</code>, which is replying the space identifier.</p>

<p>The initialization of the <code class="prettyprint">spaceID</code> field is not discussed yet, because
the context identifier is mandatory for building the space identifier.
The space identifier creation is discussed in the following section.</p>

<div class="highlight highlight-SARL"><pre>
public static val TINYMAS_DEFAULT_SPACE_ID = UUID::fromString("1db39309-8be7-4809-ad76-1ede6e792296")
var spaceID : SpaceID
def getSpaceID : SpaceID {
    this.spaceID
}
</pre></div>

<h4 id="linking-the-agent-context-to-the-space">Linking the agent context to the space</h4>

<p>We need to have a reference to the agent context that is containing this space in order
to create the space identifier and to provide a reference to this context from the space.</p>

<p>Firstly, the reference to the agent context is declared as a weak reference field, named
<code class="prettyprint">context</code>.</p>

<p>The initialization of the <code class="prettyprint">context</code> field is done by the <code class="prettyprint">setAgentContext</code> function.
As illustrated in the context definition section, this function is invoked when creating
the agent context in order to be binded to its default space.</p>

<p>The space identifier is initialized in the <code class="prettyprint">setAgentContext</code> because this is the place
where the space&#39;s UUID and the context&#39;s identifier are known.</p>

<p>Finally, the getter function for retrieving the agent context is defined too. </p>

<div class="highlight highlight-SARL"><pre>
var context : WeakReference<TMAgentContext>
package def setAgentContext(context : TMAgentContext) {
    this.context = new WeakReference(context)
    this.spaceID = new SpaceID(context.ID, TINYMAS_DEFAULT_SPACE_ID, null)
}
def getAgentContext : TMAgentContext {
    this.context.get
}
</pre></div>

<h2 id="4-first-definition-of-the-agent">4. First definition of the agent</h2>

<p>The next step is the definition of an abstraction for the SARL agent that could be
executed as a tinyMAS agent.
The easiest way to proceed is to create a tinyMAS agent class that has a reference
to the SARL agent. Then, the specific tinyMAS agent implementation will map all
the features from the tinyMAS platform to their equivalent features for the SARL agent.</p>

<h3 id="4-1-sarl-agent-inside-tinymas-agent">4.1. SARL Agent inside tinyMAS Agent</h3>

<p>We define a specific tinyMAS agent type, which is named <code class="prettyprint">TMSarlAgent</code>.
This agent definition contains a reference to the instance of the SARL agent definition,
in the field <code class="prettyprint">sarlAgent</code>. The getter of the SARL agent is also defined.</p>

<p>We define the <code class="prettyprint">getID</code> function in order to easily retrieve the unique identifier of the
agent. This unique identifier is the identifier of the SARL agent.</p>

<p>A constructor is defined for initializing the <code class="prettyprint">sarlAgent</code> field.</p>

<p><caution>The constructor will be refined and redefined in the rest of this document.</caution></p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends org.arakhne.tinyMAS.core.Agent {
    val sarlAgent : io.sarl.lang.core.Agent
    protected def getSarlAgent : io.sarl.lang.core.Agent {
        this.sarlAgent
    }
    def getID : UUID {
        this.sarlAgent.ID
    }
    new (sarlAgent : io.sarl.lang.core.Agent) {
        this.sarlAgent = sarlAgent
    }
}
</pre></div>

<h3 id="4-2-firing-sarl-events">4.2. Firing SARL events</h3>

<p>Event-based interaction is at the heart of the interaction mechanisms that could be used by the SARL agent.
The <code class="prettyprint">TMSarlAgent</code> class must provide tools for routing events when the basic interaction mechanism of
tinyMAS is based on messages.</p>

<p>The first feature to implement is the firing/routing of SARL event. We define the <code class="prettyprint">fireEvent</code> function that
is extracting the SARL agent&#39;s behavior units (the <code class="prettyprint">on</code> blocks of code), and is calling them with the event given as parameter.</p>

<p>Retrieving the SARL behavior unit is a algorithm that is following the SARL specifications.
Fortunately, the SARL API provides an utility class for exploring the Java definition
of an agent (by using the Java reflection mechanism), and providing the list of the
behavior units that are taken a given event as input.
The utility class is named <code class="prettyprint">BehaviorGuardEvaluatorRegistry</code>. According to the SARL API, one instance of this registry may be
created for each agent. Consequently, we created a final field named <code class="prettyprint">evaluatorRegistry</code> that references
the <code class="prettyprint">BehaviorGuardEvaluatorRegistry</code> instance.</p>

<p>The first line of <code class="prettyprint">fireEvent</code> retrieves the list of the behavior units that
are defined in the SARL agent (and any internal behavior) for the given event.</p>

<p>The second part of the <code class="prettyprint">fireEvent</code> function goes through the behavior units
for evaluating there guards. The function <code class="prettyprint">evaluateGuard</code> evaluates the guard
of the behavior unit on the given event, and, if the guard is true,
it fills the given list of handlers with a call to the behavior unit&#39;s code. </p>

<p>The third part of the <code class="prettyprint">fireEvent</code> function invokes the behavior units&#39; code that have a true guard.</p>

<div class="highlight highlight-SARL"><pre>
val evaluatorRegistry = new BehaviorGuardEvaluatorRegistry

package def fireEvent(^event : Event) {
    var evaluators = this.evaluatorRegistry.getBehaviorGuardEvaluators(^event)
    var handlers : Collection<Runnable> = new ArrayList
    for (evaluator : evaluators) {
        evaluator.evaluateGuard(^event, handlers);
    }

    for (handler : handlers) {
        handler.run();
    }
}
</pre></div>

<h3 id="4-3-registering-the-sarl-agent-as-behavior-unit-provider">4.3. Registering the SARL agent as behavior unit provider</h3>

<p>For enabling the <code class="prettyprint">BehaviorGuardEvaluatorRegistry</code> instance to retrieve the behavior units
of the SARL agent (and any internal behavior), we must register the SARL agent
as a provider of behavior units to the <code class="prettyprint">BehaviorGuardEvaluatorRegistry</code> instance.</p>

<p>The easier way to proceed is to register the SARL agent when the tinyMAS agent is starting;
and to unregister the SARL agent when the tinyMAS agent is stopping.
These two life-cycle functions are supported by the <code class="prettyprint">start</code> and [:stopfct] functions in the tinyMAS
platform.</p>

<div class="highlight highlight-SARL"><pre>
def start {
    super.start
    this.evaluatorRegistry.register(getSarlAgent())
}
def stop {
    this.evaluatorRegistry.unregister(getSarlAgent())
    super.stop
}
</pre></div>

<h3 id="4-4-receiving-sarl-events">4.4. Receiving SARL events</h3>

<p>For enabling the receiving of SARL events, we need to define a specific SARL event listener.
The easier way is to implement the <code class="prettyprint">EventListener</code> interface from the SARL API (see the code
below).</p>

<p>The implementation of the <code class="prettyprint">EventListener</code> interface implies to implement the
<code class="prettyprint">receiveEvent</code> function. This function is called by the SARL infrastructure each time
an event must be treated by the agent, i.e. when the agent receives the event.</p>

<p>The function <code class="prettyprint">receiveEvent</code> calls the already implemented function <code class="prettyprint">fireEvent</code>.
Nevertheless, the <code class="prettyprint">receiveEvent</code> function must ensure that the given event has
a source, i.e. the address of the sender of the event.
If the event has no source, the value of the source is forced to the address of the current
SARL agent.</p>

<p>In order to create the address of the current agent, we must know the
address of the agent in the default interaction space, and consequently, the default context
in which the agent exists.
We defined the <code class="prettyprint">defaultSpace</code> field and the corresponds getter function for storing the
default space of the agent.
For initializing this field, we redefine the constructor.</p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends org.arakhne.tinyMAS.core.Agent implements io.sarl.lang.core.EventListener {
    // [...]
    val defaultSpace : WeakReference<TMDefaultSpace>
    protected def getDefaultSpace : TMDefaultSpace {
        this.defaultSpace.get
    }
    def receiveEvent(^event : Event) {
        if (^event.source === null) {
            ^event.source = getDefaultSpace.getAddress(getSarlAgent.ID)
        }
        fireEvent(^event)
    }
    new (defaultSpace : TMDefaultSpace, sarlAgent : io.sarl.lang.core.Agent) {
        this.defaultSpace = new WeakReference(defaultSpace)
        this.sarlAgent = sarlAgent
    }
}
</pre></div>

<h3 id="4-5-initialize-and-destroy-events">4.5. Initialize and Destroy events</h3>

<p>According to the SARL specification, two events must be fired for supporting the
agents&#39; life-cycle. The first event corresponds to the initialization of the agent,
the <code class="prettyprint">Initialize</code> event. And, the second event corresponds to the destruction of the
agent, the <code class="prettyprint">Destroy</code> event.</p>

<p>The tinyMAS implementation of the SRE must fire these two events according
to the tinyMAS agent life-cycle. In this platform, the starting of the agents
is supported by the <code class="prettyprint">start</code> function. And the destruction of the agents is supported
by the <code class="prettyprint">stop</code> function.</p>

<p>For firing the <code class="prettyprint">Initialize</code> event, we need to create an instance of this event into
the <code class="prettyprint">start</code> function. But, from the SARL API documentation, the <code class="prettyprint">Initialize</code> event
must take the initialization parameters to pass to the agent at its start-up.
For supporting these initialization parameters, we define the <code class="prettyprint">parameters</code> field that is
initialized in the agent type constructor.
Then, the <code class="prettyprint">start</code> function is updated for setting the parameters of the <code class="prettyprint">Initialize</code> event;
and for firing the event with a call to the <code class="prettyprint">receiveEvent</code> function.</p>

<p>By symmetry, the <code class="prettyprint">Destroy</code> event is initialize and fired in the <code class="prettyprint">stop</code> function of the
agent type.</p>

<div class="highlight highlight-SARL"><pre>
var spawnerID : UUID
var parameters : Object[]

new (defaultSpace : TMDefaultSpace, sarlAgent : io.sarl.lang.core.Agent, spawnerID : UUID, parameters : Object[]) {
    this.defaultSpace = new WeakReference(defaultSpace)
    this.sarlAgent = sarlAgent
    this.spawnerID = spawnerID
    this.parameters = parameters
}
def start {
    super.start
    this.evaluatorRegistry.register(getSarlAgent())

    var initializeEvent = new Initialize(this.spawnerID, this.parameters)
    this.spawnerID = null
    this.parameters = null
    receiveEvent(initializeEvent)
}
def stop {
    receiveEvent(new Destroy)
    this.evaluatorRegistry.unregister(getSarlAgent())
    super.stop
}
</pre></div>

<h2 id="5-tool-for-spawning-agents">5. Tool for spawning agents</h2>

<p>Spawning agents is a key feature of the execution platform.
This feature is used for booting the initial agent, and by the agent built-in capacities
for creating new agents.</p>

<p>In order to provide a reusable spawning function, we define the <code class="prettyprint">Spawner</code> utility class
that contains the static definition of the spawning functions of SARL agents on the tinyMAS
platform.</p>

<h3 id="5-1-creating-a-tinymas-agent-from-a-sarl-agent">5.1. Creating a tinyMAS agent from a SARL agent</h3>

<p>The first utility function that we define is <code class="prettyprint">createAgent</code>.
It enables to create an instance of <code class="prettyprint">TMSarlAgent</code> from a SARL agent type.</p>

<p>The parameters of the functions are the ones required for building an instance of a SARL agent:</p>

<ul>
<li><code class="prettyprint">defaultSpace</code>: the instance of the default space in which the SARL agent will interact.</li>
<li><code class="prettyprint">agentType</code> : the type of SARL agent to create.</li>
<li><code class="prettyprint">spawerID</code> : the identifier of the agent&#39;s spanwer, or <code>null</code> if the platform has spawned the agent.</li>
<li><code class="prettyprint">parentID</code> : the identifier of the agent&#39;s parent, usually the identifier of the default context in the timeMAS SRE.</li>
<li><code class="prettyprint">agentID</code> : the identifier to give to the created agent, or <code>null</code> if the identifier must be randomly selected.</li>
<li><code class="prettyprint">params</code> : the initialization parameters to pass to the created SARL agent.</li>
</ul>

<p>The function replies the created tinyMAS agent that is binded to the SARL agent.</p>

<p>The code of the SARL agent creation is based on the call to the SARL agent constructor, as
defined in the SARL specification. By default, the SARL agent agents have a
constructor with three parameters:</p>

<ul>
<li>first parameter of type <code class="prettyprint">BuiltinCapacitiesProvider</code>: a provider of built-in capacity. Here we pass <code>null</code> as argument to the constructor in order to ignore the default initialization of the built-in capacities. This initialization will be done manually in one of the following sections.</li>
<li>second parameter of type <code class="prettyprint">UUID</code>: the identifier of the parent context of the created agent.</li>
<li>third parameter of type <code class="prettyprint">UUID</code>: the identifier of the created agent.</li>
</ul>

<p>The <code class="prettyprint">createAgent</code> function should ensure the given agent type could be executed on the current instance of
the tinyMAS platform. For that, we introduce two tests:</p>

<ul>
<li>check if the given agent type is a sub-type of the <code class="prettyprint">Agent</code> type provided in the SARL API; and</li>
<li>use the <code class="prettyprint">SarlSpecificationChecker</code> provided in the SARL API for verifying that the given agent type was generated with a SARL specification version that is compatible with the version supported by tinyMAS. This interface provides default method implementation.</li>
</ul>

<p>The obtained code is:</p>

<div class="highlight highlight-SARL"><pre>
static val SPECIFICATION_CHECKER : SarlSpecificationChecker = new SarlSpecificationChecker {}

static def createAgent(
        defaultSpace : TMDefaultSpace, 
        agentType : Class<? extends io.sarl.lang.core.Agent>,
        spawnerID : UUID,
        parentID : UUID,
        agentID : UUID,
        params : Object*)
        : TMSarlAgent {
    if (typeof(io.sarl.lang.core.Agent).isAssignableFrom(agentType)
        && SPECIFICATION_CHECKER.isValidSarlElement(agentType)) {
        var theAgentID = if (agentID === null) UUID::randomUUID else agentID
        var theAgentType = agentType as Class<? extends io.sarl.lang.core.Agent>
        var cons = theAgentType.getConstructor(typeof(BuiltinCapacitiesProvider), typeof(UUID), typeof(UUID))
        var sarlAgent = cons.newInstance(null, parentID, theAgentID)
        var tmAgent = new TMSarlAgent(defaultSpace, sarlAgent, spawnerID, params)
        return tmAgent
    }
    return null
}
</pre></div>

<h3 id="5-2-launching-a-tinymas-sarl-agent-on-the-tinymas-kernel">5.2. Launching a tinyMAS-SARL agent on the tinyMAS kernel</h3>

<p>Now we have a function for creating a tinyMAS-SARL agent, it is necessary to provide
an utility function for launching this tinnyMAS-SARL agent on the tinyMAS kernel.</p>

<p>We define the following <code class="prettyprint">spawn</code> function thats takes as parameter the timasMAS
kernel instance, and the agent to launch.</p>

<p>The function create the agent identifier of the agent in the tinyMAS platform, from
the identifier of the kernel, and the SARL agent identifier.</p>

<p>Finally, the function invokes the agent launching function of the tinyMAS kernel.</p>

<div class="highlight highlight-SARL"><pre>
static def spawn(
        kernel : Kernel,
        ^agent : TMSarlAgent) {
    var tmid = new AgentIdentifier(kernel.kernelId, ^agent.ID.toString)
    kernel.addAgent(tmid, ^agent)
}
</pre></div>

<h3 id="5-3-general-utility-function-for-spawning-agents">5.3. General utility function for spawning agents</h3>

<p>Now, we could define a general spawning function that invokes the two previously
defined functions.</p>

<div class="highlight highlight-SARL"><pre>
static def spawn(
        kernel : Kernel,
        defaultSpace : TMDefaultSpace, 
        agentType : Class<? extends io.sarl.lang.core.Agent>,
        spawnerID : UUID,
        parentID : UUID,
        agentID : UUID,
        params : Object*) : UUID {
    var ^agent = createAgent(defaultSpace, agentType, spawnerID, parentID, agentID, params)
    if (^agent !== null) {
        spawn(kernel, ^agent)
        return ^agent.ID
    }
    return null
}
</pre></div>

<h2 id="6-definition-of-the-built-in-capacities">6. Definition of the built-in capacities</h2>

<p>One of the key principle in the SARL specification is that each SARL agent is
provided with a collection of built-in capacities that are provided by the run-time
environment.
In this section, we define the built-in capacities that are implemented with the
tinyMAS API.</p>

<p><caution>In the following code, we assume that the given implementation is
an inner class of the <code class="prettyprint">TMSarlAgent</code> class. In this way, we will be able to access
to the features of the agent type: <code class="prettyprint">getId</code>, <code class="prettyprint">getDefaultSpace</code>, <code class="prettyprint">killMe</code>.</p>

<h3 id="6-1-definition-of-the-logging-skill">6.1. Definition of the Logging skill</h3>

<p>The easiest built-in capacity to implement is the <code class="prettyprint">Logging</code> capacity.
This capacity enables the SARL agent to log messages on the output console.</p>

<p>The basic principle for implementing a built-in capacity is to create
a class extending the <code class="prettyprint">Skill</code> class, and implementing the capacity to
implement, in this case the <code class="prettyprint">Logging</code> capacity.</p>

<p>There is not particular issue with the coding of this buil-in capacity.
The code is self-explaining.</p>

<div class="highlight highlight-SARL"><pre>
class LoggingSkill extends Skill implements Logging {
    def setLoggingName(message : String) {
        getId.stringRepresentation = message
    }
    def isErrorLogEnabled : boolean {
        true
    }
    def isWarningLogEnabled : boolean {
        true
    }
    def isInfoLogEnabled : boolean {
        true
    }
    def isDebugLogEnabled : boolean {
        true
    }
    def getLogLevel : int {
        0
    }
    def setLogLevel(level : int) {
    }
    def getLogger : Logger {
        null
    }
    def error(message : Object, exception : Throwable = null, parameters : Object*) {
        System::out.println("[" + getId.getString + "] ERROR: " + message)
        if (exception !== null) {
            exception.printStackTrace(System::out)
        }
    }
    def error(messageProvider : Supplier<String>) {
        System::out.println("[" + getId.getString + "] ERROR: " + messageProvider.get)
    }
    def warning(message : Object, exception : Throwable = null, parameters : Object*) {
        System::out.println("[" + getId.getString + "] WARNING: " + message)
        if (exception !== null) {
            exception.printStackTrace(System::out)
        }
    }
    def warning(messageProvider : Supplier<String>) {
        System::out.println("[" + getId.getString + "] WARNING: " + messageProvider.get)
    }
    def info(message : Object, parameters : Object*) {
        System::out.println("[" + getId.getString + "] INFO: " + message)
    }
    def info(messageProvider : Supplier<String>) {
        System::out.println("[" + getId.getString + "] INFO: " + messageProvider.get)
    }
    def debug(message : Object, parameters : Object*) {
        System::out.println("[" + getId.getString + "] DEBUG: " + message)
    }
    def debug(messageProvider : Supplier<String>) {
        System::out.println("[" + getId.getString + "] DEBUG: " + messageProvider.get)
    }
}
</pre></div>

<h3 id="6-2-definition-of-the-lifecycle-skill">6.2. Definition of the Lifecycle skill</h3>

<p>The <code class="prettyprint">Lifecycle</code> capacity is one of the must used capacity.
It provides the support of the SARL agent life-cycle.</p>

<h4 id="spawning-agents-in-the-default-space">Spawning agents in the default space</h4>

<p>Consider the agent execution mechanism in the tinyMAS platform: inside an infinite loop, each agent is run. This algorithmic
principle may be described by the following algorithm:</p>

<div class="highlight highlight-SARL"><pre>
while (true) {
    for(a : whitePages.allAgents) {
        a.live
    }
    refreshKernelState
}
</pre></div>

<p>The tinyMAS platform is designed for updating the kernel state after all the agent have been ran.
Consequently, the tinyMAS platform does not support the creation of agents during the execution of another agent.
If an agent spawns another agent, the real initialization of the spawned agent must be delayed until the 
<code class="prettyprint">refreshKernelState</code> is invoked.</p>

<p>This particular design of the tinyMAS platform is at the opposite of
the standard spawning principle in SARL: the agents are spawned
when the spawning function is called.</p>

<p>For fixing this issue, we need to implement a buffer of spawned
agents, that will be filled by the SARL spawning functions, and consumed
by the <code class="prettyprint">refreshKernelState</code> function.</p>

<p>The simplest place where to put this code in the <code class="prettyprint">TMDefaultSpace</code> type.
Indeed, we could assume that the agent spawning always occurs in the default space.
We update the <code class="prettyprint">TMDefaultSpace</code> class as described in the following code. </p>

<p>We define the <code class="prettyprint">agentsToLaunch</code> field as the spawn agent buffer.</p>

<p>The [:spawnfct] function creates the agent instance, based on the <code class="prettyprint">Spawner</code> utility class,
and adds the created agent into the buffer.</p>

<p>The consumption of the spawn agent buffer is supported by the `<code class="prettyprint">consumeAgentToLaunch</code>
function. This function replies the buffer content, and clears the buffer.</p>

<div class="highlight highlight-SARL"><pre>
var agentsToLaunch : List<TMSarlAgent> = new ArrayList
def spawn(
        anAgent : Class<? extends io.sarl.lang.core.Agent>,
        spawnerID : UUID,
        agentID : UUID,
        params : Object*)
        : UUID {
    val ^agent = Spawner::createAgent(
            this,
            anAgent,
            spawnerID,
            TINYMAS_DEFAULT_SPACE_ID,
            agentID,
            params)
    this.agentsToLaunch += ^agent
    return ^agent.ID
}
def consumeAgentToLaunch : Iterable<TMSarlAgent> {
    var iterable = this.agentsToLaunch
    this.agentsToLaunch = new ArrayList
    return iterable
}
</pre></div>

<h4 id="first-definition-of-the-skill">First definition of the skill</h4>

<p>The functions for spawning the agents delegate the spawning to
the default space (as defined in the previous section).</p>

<p>The <code class="prettyprint">killMe</code> function enables to stop the agent which is invoking
this function. The agent killing is delegated to the tinyMAS agent killing
function, also named <code class="prettyprint">killMe</code>. The <code class="prettyprint">owner</code> is a syntactic simplification of
a call to <code class="prettyprint">getOwner</code>, which replies the agent owning the skill.</p>

<p>One important point regarding the expected behavior of the SARL <code class="prettyprint">killMe</code> is
that is must never return from the point of view of its caller.
For simulating this behavior, we could use the exception mechanism by throwing
a specific internal exception that is not a real error but
represents the &quot;no-return code&quot; case.
This specific exception is named <code class="prettyprint">NoReturnCodeException</code>, and is defined
in the next section.</p>

<div class="highlight highlight-SARL"><pre>
class LifecycleSkill extends Skill implements Lifecycle {
    def spawn(
            agentClass : Class<? extends io.sarl.lang.core.Agent>,
            params : Object*)
            : UUID {
        return defaultSpace.spawn(agentClass, null, params)
    }
    def spawn(
            nbAgents : int,
            agentClass : Class<? extends io.sarl.lang.core.Agent>,
            params : Object*)
            : Collection<UUID> {
        var list = newArrayList
        for (i : 1..nbAgents) {
            var id = defaultSpace.spawn(agentClass, null, params)
            if (id !== null) {
                list += id
            }
        }
        return list
    }
    def spawnInContext(
            agentClass : Class<? extends io.sarl.lang.core.Agent>,
            context : AgentContext,
            params : Object*)
            : UUID {
        if (context.ID == defaultSpace.agentContext.ID) {
            return defaultSpace.spawn(agentClass, owner.ID, null, params)
        }
        return null
    }
    def spawnInContext(
            nbAgents : int,
            agentClass : Class<? extends io.sarl.lang.core.Agent>,
            context : AgentContext,
            params : Object*)
            : Collection<UUID> {
        var list = newArrayList
        if (context.ID == defaultSpace.agentContext.ID) {
            for (i : 1..nbAgents) {
                var id = defaultSpace.spawn(agentClass, null, params)
                if (id !== null) {
                    list += id
                }
            }
        }
        return list
    }
    def spawnInContextWithID(
            agentClass : Class<? extends io.sarl.lang.core.Agent>,
            agentID : UUID,
            context : AgentContext,
            params : Object*)
            : UUID {
        if (context.ID == defaultSpace.agentContext.ID) {
            return defaultSpace.spawn(agentClass, owner.ID, agentID, params)
        }
        return null
    }
    def killMe {
        (owner as TMSarlAgent).killMe
        throw new NoReturnCodeException
    }
}
</pre></div>

<h4 id="support-of-the-no-return-functions">Support of the no-return functions</h4>

<p>The exception that is simulating a no-return-code is defined as:</p>

<div class="highlight highlight-SARL"><pre>
class NoReturnCodeException extends RuntimeException {
}
</pre></div>

<h4 id="catching-the-no-return-code-exception">Catching the no-return-code exception</h4>

<p>For avoiding the tinyMAS platform to stop because the <code class="prettyprint">NoReturnCodeException</code>
was not caught, we must redefined the <code class="prettyprint">fireEvent</code> function in the <code class="prettyprint">TMSarlAgent</code>
type. Indeed, this function is the one which is running the code of the SARL event
handlers in which the SARL <code class="prettyprint">killMe</code> function could be invoked.</p>

<p>Each call to a piece of SARL code is enclosing by a try-catch statement that
is simply ignoring the <code class="prettyprint">NoReturnCodeException</code> exception.</p>

<div class="highlight highlight-SARL"><pre>
package def fireEvent(^event : Event) {
    var evaluators = this.evaluatorRegistry.getBehaviorGuardEvaluators(^event)
    var handlers : Collection<Runnable> = new ArrayList
    for (evaluator : evaluators) {
        try {
            evaluator.evaluateGuard(^event, handlers);
        } catch (e : NoReturnCodeException) {
        }
    }

    for (handler : handlers) {
        try {
            handler.run()
        } catch (e : NoReturnCodeException) {
        }
    }
}
</pre></div>

<h3 id="6-3-definition-of-the-defaultcontextinteractions-skill">6.3. Definition of the DefaultContextInteractions skill</h3>

<p>The <code class="prettyprint">DefaultContextInteractions</code> capacity enables the agent to have
interaction in the default space.</p>

<h4 id="first-definition-of-the-skill">First definition of the skill</h4>

<p>The first and incomplete definition of the <code class="prettyprint">DefaultContextInteractions</code> capacity
for the tinyMAS platform is provided below.</p>

<p>The functions that replies the default context and the default space are defined
for replying the context and space that are referenced in the agent.
The <code class="prettyprint">owner</code> is a syntactic simplification of a call to <code class="prettyprint">getOwner</code>, which replies
the agent owning the skill.</p>

<p>The <code class="prettyprint">getAddress</code> function replies the address of the owner in the default space.
Its behavior is delegated to the <code class="prettyprint">getAddress(UUID)</code> of the default space.</p>

<p>The <code class="prettyprint">isDefaultContext</code> functions implemented in order to test if their parameters correspond
to the default context.</p>

<p>Similarly, the <code class="prettyprint">isDefaultSpace</code> functions are implemented in order to test if their parameters correspond
to the default space.</p>

<p>The <code class="prettyprint">isInDefaultSpace</code> function replies <code>true</code> if the given event is fired
into the default space. The function behavior is delegated to the <code class="prettyprint">isDefaultSpace</code> function
with the event source identifier as argument.</p>

<div class="highlight highlight-SARL"><pre>
class DefaultContextInteractionsSkill extends Skill implements DefaultContextInteractions {
    def getDefaultContext : AgentContext {
        ((owner as TMSarlAgent).defaultSpace as TMDefaultSpace).agentContext
    }
    def getDefaultSpace : EventSpace {
        (owner as TMSarlAgent).defaultSpace
    }
    def getDefaultAddress : Address {
        var o = owner as TMSarlAgent
        o.defaultSpace.getAddress(o.sarlAgent.ID)
    }
    def isDefaultContext(context : AgentContext) : boolean {
        context.ID == (defaultSpace as TMDefaultSpace).agentContext.ID
    }
    def isDefaultContext(contextID : UUID) : boolean {
        contextID == (defaultSpace as TMDefaultSpace).agentContext.ID
    }
    def isDefaultSpace(^space : Space) : boolean {
        ^space.spaceID == defaultSpace.spaceID
    }
    def isDefaultSpace(^space : SpaceID) : boolean {
        ^space == defaultSpace.spaceID
    }
    def isDefaultSpace(^space : UUID) : boolean {
        ^space == defaultSpace.spaceID.ID
    }
    def isInDefaultSpace(^event : Event) : boolean {
        isDefaultSpace(^event.source.spaceID)
    }
}
</pre></div>

<h4 id="firing-events-in-the-default-space">Firing events in the default space</h4>

<p>Firing events in the default space could be done by calling the <code class="prettyprint">emit</code>
and <code class="prettyprint">willReceive</code> functions.</p>

<p>The <code class="prettyprint">emit</code> function fires the given event into the default space.
Optionally, a scope could be provided for restricting the set of the
event&#39;s receivers. The <code class="prettyprint">emit</code> function delegates its behavior to
the <code class="prettyprint">emit</code> function of the default space.</p>

<p>One import point in the implementation of the <code class="prettyprint">emit</code> function is the
check of the event&#39;s source. Indeed, sometimes, the given event has no source
address set. Because the default space could not set this address when it is
<code class="prettyprint">null</code>, we must check this case and force the value of the event source
address to the address of the current agent.</p>

<p>The <code class="prettyprint">willReceive</code> function is a inverted version of the syntactic call to the
firing function. This function enables the developer to send the event
to a specific agent with the following syntax:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">receverID.willReceive(^event)
</code></pre></div>
<p>The obtained code is:</p>

<div class="highlight highlight-SARL"><pre>
def emit(^event : Event, scope : Scope<Address> = null) {
    if (^event.source === null) {
        ^event.source = defaultSpace.getAddress(owner.ID)
    }
    defaultSpace.emit(owner.ID, ^event, scope)
}
def willReceive(receiver : UUID, ^event : Event) {
    emit(^event, Scopes::identifiers(receiver))
}
</pre></div>

<h4 id="spawning-agents-in-the-default-context">Spawning agents in the default context</h4>

<p>Spawning an agent in the default context could be done by calling the <code class="prettyprint">spawn</code> function of
the <code class="prettyprint">DefaultContextInteractions</code> capacity.
This function delegates its behavior to the <code class="prettyprint">spawn</code> function that is already defined
in the tinyMAS-SARL default space class.</p>

<div class="highlight highlight-SARL"><pre>
def spawn(agentType : Class<? extends io.sarl.lang.core.Agent>, params : Object*) : UUID {
    (defaultSpace as TMDefaultSpace).spawn(agentType, owner.ID, null, params)
}
</pre></div>

<h3 id="6-4-definition-of-the-behaviors-skill">6.4. Definition of the Behaviors skill</h3>

<p>The <code class="prettyprint">Behaviors</code> capacity enables the agent to have
sub-behaviors that could be dynamically added and removed.</p>

<h4 id="first-definition-of-the-skill">First definition of the skill</h4>

<p>The first and incomplete definition of the <code class="prettyprint">Behaviors</code> capacity for the tinyMAS platform is provided below.</p>

<p>The first function implemented is the <code class="prettyprint">asEventListener</code> function. It replies the object that could serve as a
SARL event listener for the agent. In the tinyMAS implementation, we have already implemented the <code class="prettyprint">EventListener</code>
interface in the <code class="prettyprint">TMSarlAgent</code> class. In other word, the tinyMAS agent type is already a SARL event listener by itself.
Consequently, the <code class="prettyprint">asEventListener</code> function replies the owner of the skill, i.e. the agent. </p>

<div class="highlight highlight-SARL"><pre>
class BehaviorsSkill extends Skill implements Behaviors {
    def asEventListener : EventListener {
        owner as TMSarlAgent
    }
}
</pre></div>

<h4 id="registering-a-behavior">Registering a behavior</h4>

<p>A <code class="prettyprint">Behavior</code> instance could be registered in order to be run for the current agent.
The <code class="prettyprint">registerBehavior</code> function enables the SARL developer to add a <code class="prettyprint">Behavior</code>
instance into the registered sub-behaviors of the agent.</p>

<p>In order to store the list of the sub-behavior, we must define the
<code class="prettyprint">behaviors</code> field. The content of this field is increased by the <code class="prettyprint">registerBehavior</code>
function.</p>

<div class="highlight highlight-SARL"><pre>
val behaviors : List<Behavior> = new ArrayList
def registerBehavior(attitude : Behavior) : Behavior {
    if (attitude !== null) {
        this.behaviors += attitude
    }
    return attitude
}
</pre></div>

<h4 id="unregistering-a-behavior">Unregistering a behavior</h4>

<p>The <code class="prettyprint">unregisterBehavior</code> function enables the SARL developer to remove a <code class="prettyprint">Behavior</code>
instance from the registered sub-behaviors of the agent.
The content of the <code class="prettyprint">behaviors</code> field defined in the previous section is decreased
with the given attitude.</p>

<div class="highlight highlight-SARL"><pre>
def unregisterBehavior(attitude : Behavior) : Behavior {
    if (attitude !== null) {
        this.behaviors -= attitude
    }
    return attitude
}
</pre></div>

<h4 id="waking-the-behaviors-with-an-event">Waking the behaviors with an event</h4>

<p>The SARL specification indicates that it is possible for an agent to fire an event
inside its internal context. In other words, the event will be received by
the agent, and its internal behaviors, and not by the other agents.</p>

<p>The <code class="prettyprint">wake</code> function is provided for supporting this feature.
Its implementation retrieves the SARL event listener of the agent by calling
the <code class="prettyprint">asEventListener</code> function. And, it invokes the receiving function of
the listener with the event as argument.</p>

<p>If a scope is provided, it must be used for filtering the receivers which have
an address. In the context of the tinyMAS platform, only the agent fits this requirement.
Consequently, the scope is matched against the agent&#39;s address in its internal context
(not the agent&#39;s address in the default space of its default context).
The <code class="prettyprint">getInnerAddress</code> function computes the agent&#39;s address in the agent internal context.</p>

<div class="highlight highlight-SARL"><pre>
def wake(^event : Event, scope : Scope<Address> = null) {
    if (scope === null || scope.matches(innerAddress)) {
        asEventListener.receiveEvent(^event)
    }
}
private def getInnerAddress : Address {
    var id = (owner as TMSarlAgent).ID
    return new Address(
            new SpaceID(id, UUID.randomUUID, typeof(EventSpaceSpecification)),
            id)
}
</pre></div>

<h4 id="accessing-to-the-collection-of-the-registered-behaviors">Accessing to the collection of the registered behaviors</h4>

<p>Two functions must be implemented for accessing to the internal list of the behaviors:</p>

<ul>
<li><code class="prettyprint">hasRegisteredBehavior</code> indicates if a behavior is registered; and</li>
<li><code class="prettyprint">getRegisteredBehaviors</code> replies an unmodifiable collection of the registered behaviors.</li>
</ul>

<div class="highlight highlight-SARL"><pre>
def hasRegisteredBehavior : boolean {
    !this.behaviors.isEmpty
}
def getRegisteredBehaviors : SynchronizedIterable<Behavior> {
    Collections3::unmodifiableSynchronizedIterable(this.behaviors, this)
}
</pre></div>

<p>The function call <code class="prettyprint">Collections3::unmodifiableSynchronizedIterable</code> is provided by the SARL Development Kit in order to create synchronized collections.</p>

<h4 id="updating-the-tinymas-agent-life-cycle-for-un-registering-the-behaviors">Updating the tinyMAS agent life-cycle for (un)registering the behaviors</h4>

<p>There is an key difference between the SARL run-time principle, which is fully
distributed (everything is registered, run, unregistered in parallel),
and the tinyMAS run-time principle, which is fully sequential (everything is
controlled in a big virtual loop).
Consequently, it is mandatory to map the fully-distributed point-of-view
from the SARL specification to the sequential point-of-view from tinyMAS.</p>

<h5 id="defining-buffers-of-behaviors">Defining buffers of behaviors</h5>

<p>In order to map the SARL behavior support to tinyMAS platform,
the <code class="prettyprint">BehaviorsSkill</code> type must store the registered and unregistered behaviors separately.
Indeed, the registered behaviors must become SARL event listeners in the agent context.
And, the unregistered behaviors must be SARL event listener anymore.</p>

<p>In order to separate these two subsets of behaviors, we define the two fields
<code class="prettyprint">registrationWaiters</code> and <code class="prettyprint">unregistrationWaiters</code>, which represent the behaviors
that are waiting for event listening registration, and event listener unregistration, respectively.</p>

<p>We define the <code class="prettyprint">getRegistrationWaiters</code> and <code class="prettyprint">getUnregistrationWaiters</code> functions
for replying and consuming these subsets. These functions will be invoked later,
from the tinyMAS agent living function. </p>

<div class="highlight highlight-SARL"><pre>
var registrationWaiters : List<Object> = new ArrayList
var unregistrationWaiters : List<Object> = new ArrayList
def getRegistrationWaiters : Iterable<Object> {
    val collection = this.unregistrationWaiters
    this.unregistrationWaiters = new ArrayList
    return collection
}
def getUnregistrationWaiters : Iterable<Object> {
    val collection = this.registrationWaiters
    this.registrationWaiters = new ArrayList
    return collection
}
</pre></div>

<h5 id="updating-the-buffers-of-behaviors">Updating the buffers of behaviors</h5>

<p>The <code class="prettyprint">registerBehavior</code> and <code class="prettyprint">unregisterBehavior</code> functions that are
already defined in the <code class="prettyprint">BehaviorsSkill</code> type must be redefined in order
to include the updating of the behavior&#39;s buffers.</p>

<p>In the <code class="prettyprint">registerBehavior</code> function, the registering attitude (behavior)
is added into the set of behaviors that are waiting for SARL event listening
registration.</p>

<p>The registering attitude is also remove from the set of behaviors that are
waiting for SARL event listening unregistration. It avoids to have registration
and unregistration at the same time for the same attitude.</p>

<p>In the <code class="prettyprint">unregisterBehavior</code> function, the unregistering attitude (behavior)
is added into the set of behaviors that are waiting for SARL event listening
unregistration. And, it is removed from the set of whose waiting for registration.</p>

<div class="highlight highlight-SARL"><pre>
def registerBehavior(attitude : Behavior) : Behavior {
    if (attitude !== null) {
        this.behaviors += attitude
        this.registrationWaiters += attitude
        this.unregistrationWaiters -= attitude
    }
    return attitude
}
def unregisterBehavior(attitude : Behavior) : Behavior {
    if (attitude !== null) {
        this.behaviors -= attitude
        this.registrationWaiters -= attitude
        this.unregistrationWaiters += attitude
    }
    return attitude
}
</pre></div>

<h5 id="updating-the-tinymas-agent-living-function">Updating the tinyMAS agent living function</h5>

<p>In order to map the (un)registered the SARL behaviors at the correct
instant during the tinyMAS agent life-cycle, we must define the
agent living function (<code class="prettyprint">live</code>) in the <code class="prettyprint">TMSarlAgent</code> type.</p>

<p>We assume that the <code class="prettyprint">behaviorsSkill</code> field is defined and set
(Section <a href="#7-creating-built-in-capacity-instances-in-the-agent">Creating
built-in capacity instances in the agent</a> explains how to proceed).
This field contains a reference to the <code class="prettyprint">BehaviorsSkill</code> skill owned by the agent.</p>

<p>We assume that the <code class="prettyprint">evaluatorRegistry</code> field is defined, and contains
a reference to the <code class="prettyprint">BehaviorGuardEvaluatorRegistry</code> instance that is used
for managing the agent event bus (see the previous sections for its definition).</p>

<p>The <code class="prettyprint">live</code> function is implemented in order to retrieve the behaviors, which
are waiting for SARL event listening (un)registration. For each behavior,
the (un)registration function on the <code class="prettyprint">BehaviorGuardEvaluatorRegistry</code> instance
is called.</p>

<p>Putting this code in the <code class="prettyprint">live</code> function ensures that the agent&#39;s behaviors
are (un)registered at the beginning of each step of the agent&#39;s life, and not
in parallel to the other agent&#39;s tasks.</p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends Agent implements EventListener {
    // [...]
    var behaviorsSkill : BehaviorsSkill
    def live {
        for (beh : this.behaviorsSkill.registrationWaiters) {
            this.evaluatorRegistry.register(beh)
        }
        for (beh : this.behaviorsSkill.unregistrationWaiters) {
            this.evaluatorRegistry.unregister(beh)
        }
    }
}
</pre></div>

<h4 id="proper-un-installation-of-the-skill">Proper un-installation of the skill</h4>

<p>Because a skill could be dynamically removed from an agent, we must
unregister each agent&#39;s behavior when the skill is uninstalled.</p>

<p>In the <code class="prettyprint">BehaviorsSkill</code> type, we define the <code class="prettyprint">uninstall</code> function, which
is automatically invoked when the skill is removed from the agent.</p>

<p>The code of the <code class="prettyprint">uninstall</code> function goes through all the behaviors, and
invokes the <code class="prettyprint">unregister</code> function of the agent&#39;s event bus with each of them as
argument.</p>

<div class="highlight highlight-SARL"><pre>
protected def uninstall(stage : UninstallationStage) {
    switch (stage) {
    case PRE_DESTROY_EVENT: {
        }
    case POST_DESTROY_EVENT: {
            for (beh : this.behaviors) {
                (owner as TMSarlAgent).evaluatorRegistry.unregister(beh)
            }
        }
    }
}
</pre></div>

<h3 id="6-5-definition-of-the-schedules-skill">6.5. Definition of the Schedules skill</h3>

<p>The <code class="prettyprint">Schedules</code> capacity enables the agent to run periodic and not-periodic tasks.</p>

<h4 id="definition-of-the-synchronous-agent-task-type">Definition of the synchronous agent task type</h4>

<p>The SARL <code class="prettyprint">AgentTask</code> type represents a task for the SARL agents.
The default implementation of <code class="prettyprint">AgentTask</code> assumes that the task
will be run asynchronously (usually with a Java thread execution pool).</p>

<p>Unfortunately, the tinyMAS platform forbids to use a thread execution pool
because of its internal design specification: the tintMAS platform execution
mechanism is synchronous.</p>

<p>In order to run an <code class="prettyprint">AgentTask</code> on tinyMAS, we must define a subtype, named <code class="prettyprint">Task</code>
that is providing the features, which are usually given by the Java thread
execution pool:</p>

<ul>
<li>cancellation of the task,</li>
<li>period of execution of the task.</li>
</ul>

<div class="highlight highlight-SARL"><pre>
class Task extends AgentTask {
    var isCanceled = false
    
    var period = 0l
    
    def isCanceled : boolean {
        this.isCanceled
    }
    
    def cancel {
        this.isCanceled = true
    }
    
    def getPeriod : long {
        this.period
    }
    
    def setPeriod(period : long) {
        this.period = period
    }
}
</pre></div>

<h4 id="first-definition-of-the-skill">First definition of the skill</h4>

<p>The first and incomplete definition of the <code class="prettyprint">SchedulesSkill</code> type
is described below. This type is the tinyMAS implementation of
the <code class="prettyprint">Schedules</code> capacity.</p>

<p>The <code class="prettyprint">task</code> function enables to create a SARL task with the given
name. The implementation creates the task instance, and sets the name
of the task with a unique value.</p>

<div class="highlight highlight-SARL"><pre>
@PrivateAPI(isCallerOnly = true)

class SchedulesSkill extends Skill implements Schedules {
    def task(name : String) : AgentTask {
        var theTask = new Task
        theTask.name = name ?: UUID.randomUUID.toString
        return theTask
    }
}
</pre></div>

<p>Note: <code class="prettyprint">PrivateAPI</code> is an annotation that gives you access to the functions that are within the private API of SARL.</p>

<h4 id="scheduling-an-agent-task">Scheduling an agent task</h4>

<p>The first function, named <code class="prettyprint">in</code>, for scheduling an agent task permits to run the given task after a given delay.</p>

<p>If the task agent us <code>null</code>, the <code class="prettyprint">in</code> function creates an agent task instance with an unique name.</p>

<p>The <code class="prettyprint">in</code> function computes the time at which the task should be run.
This computation is based on a call to the <code class="prettyprint">getSimulationTime</code> function, which
is providing the current time in the tinyMAS platform. This current time is
increased with the delay given as parameter of the <code class="prettyprint">in</code> function for obtaining
the task&#39;s execution time.</p>

<p>After associated the task to the procedure given as parameter, the <code class="prettyprint">in</code> function
schedule the task by calling the <code class="prettyprint">scheduleTask</code> function.</p>

<p>The <code class="prettyprint">scheduleTask</code> function takes two parameters: the time at which the
task must start, and the task to execute. This function updates the collection
of the tasks to execute, which is stored and accessible with the <code class="prettyprint">tasks</code> field.
The <code class="prettyprint">tasks</code> field contains a map from the task starting time to the collection
of tasks to be started at this time.</p>

<div class="highlight highlight-SARL"><pre>
def in(task : AgentTask = null, delay : long, procedure : (io.sarl.lang.core.Agent) => void) : AgentTask {
    var theTask = task
    if (theTask === null) {
        theTask = new Task
        theTask.name = UUID.randomUUID.toString
    }
    var time = (owner as TMSarlAgent).getSimulationTime(TimeUnit::MILLISECONDS) as long + delay
    theTask.procedure = procedure
    scheduleTask(time, theTask)
    return theTask
}
val tasks : Map<Long, Collection<AgentTask>> = new TreeMap
private def scheduleTask(at : long, task : AgentTask) {
    var list = this.tasks.get(at)
    if (list === null) {
        list = new ArrayList
        this.tasks.put(at, list)
    }
    list += task
}
</pre></div>

<h4 id="executed-an-agent-task-once">Executed an agent task once</h4>

<p>It is possible to execute a task only one time by calling the <code class="prettyprint">execute</code> function.
In the tinyMAs implementation, the <code class="prettyprint">execute</code> function schedule the task for the
next simulation step.</p>

<div class="highlight highlight-SARL"><pre>
def execute(task : AgentTask = null, procedure : (io.sarl.lang.core.Agent) => void) : AgentTask {
    return in(
        task,
        (owner as TMSarlAgent).getSimulationStepDuration(TimeUnit::MILLISECONDS) as long,
        procedure)
}
</pre></div>

<h4 id="scheduling-a-periodic-agent-task">Scheduling a periodic agent task</h4>

<p>It is possible to schedule periodic tasks by calling the <code class="prettyprint">every</code> function.
The definition of this function is similar to the definition of
the <code class="prettyprint">in</code> function, except that the <code class="prettyprint">period</code> field of the <code class="prettyprint">Task</code> is set
with the period duration, which is given as parameter. </p>

<p>The <code class="prettyprint">atFixedDelay</code> function delegates to the <code class="prettyprint">every</code> function because the task running
algorithm implies that these two types of execution approach will be the same on tinyMAS.</p>

<div class="highlight highlight-SARL"><pre>
def every(task : AgentTask = null, period : long, procedure : (io.sarl.lang.core.Agent) => void) : AgentTask {
    var theTask = task
    if (theTask === null) {
        theTask = new Task
        theTask.name = UUID.randomUUID.toString
    }
    var time = (owner as TMSarlAgent).getSimulationTime(TimeUnit::MILLISECONDS) as long + period
    theTask.procedure = procedure
    if (theTask instanceof Task) {
        theTask.period = period
    }
    scheduleTask(time, theTask)
    return theTask
}
def atFixedDelay(task : AgentTask = null, delay : long, procedure : (io.sarl.lang.core.Agent) => void) : AgentTask {
    return task.every(delay, procedure)
}
</pre></div>

<h4 id="canceling-an-agent-task">Canceling an agent task</h4>

<p>The <code class="prettyprint">Schedules</code> capacity provides the feature for canceling a task by calling
the <code class="prettyprint">cancel</code> function.
This function delegates to the <code class="prettyprint">cancel</code> function of the <code class="prettyprint">Task</code> type.</p>

<div class="highlight highlight-SARL"><pre>
def cancel(task : AgentTask, mayInterruptIfRunning : boolean = true) : boolean {
    if (task instanceof Task) {
        task.cancel
        return true
    }
    return false
}
</pre></div>

<h4 id="running-the-scheduled-tasks">Running the scheduled tasks</h4>

<p>Executing the registered tasks must be supported by a specific function, named <code class="prettyprint">runTasks</code>.</p>

<p>This function determines the current time (<code class="prettyprint">currentTime</code>) in the tinyMAS platform.
Then, it retrieves the <code class="prettyprint">list</code> of the tasks to start at the current time.</p>

<p>For each task in the <code class="prettyprint">list</code>, the function tests if the task was canceled or not.
If the task was not canceled, the function retrieves the task&#39;s guard (the condition
of execution) and evaluates it.</p>

<p>If the task&#39;s guard is evaluated to <code>true</code>, the function executes
the procedure associated to the task.</p>

<p>Finally, the <code class="prettyprint">runTasks</code> function reschedules the task is its periodic execution
period is greater than zero. </p>

<div class="highlight highlight-SARL"><pre>
def runTasks {
    var currentTime = (owner as TMSarlAgent).getSimulationTime(TimeUnit::MILLISECONDS) as long
    var list = this.tasks.remove(currentTime)
    if (list !== null) {
        for (task : list) {
            var canceled = false
            if (task instanceof Task) {
                canceled = task.canceled
            }
            if (!canceled) {
                var guard = task.guard
                if (guard === null || guard.apply((owner as TMSarlAgent).sarlAgent)) {
                    var code = task.procedure
                    if (code !== null) {
                        code.apply((owner as TMSarlAgent).sarlAgent)
                    }
                    if (task instanceof Task) {
                        if (task.period > 0) {
                            scheduleTask(currentTime + task.period, task)
                        }
                    }
                }
            }
        }
    }
}
</pre></div>

<h4 id="updating-the-tinymas-agent-living-function">Updating the tinyMAS agent living function</h4>

<p>Now the <code class="prettyprint">runTasks</code> function is defined in the <code class="prettyprint">SchedulesSkill</code> class, we could update
the tinyMAS agent life-cycle in order to invoke this function.</p>

<p>The agent tasks must be run at each step of the tinyMAS agent life. Consequently,
we must redefine the <code class="prettyprint">live</code> function in the <code class="prettyprint">TMSarlAgent</code> class for invoking <code class="prettyprint">runTasks</code>.</p>

<p>In order to call the <code class="prettyprint">runTasks</code> function, we must assume that the <code class="prettyprint">schedulesSkill</code>
field is defined as a reference to the instance of <code class="prettyprint">SchedulesSkill</code> built-in capacity.
How this field is set will be described in a further section.</p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends Agent implements EventListener {
    // [...]
    var schedulesSkill : SchedulesSkill
    def live {
        for (beh : this.behaviorsSkill.registrationWaiters) {
            this.evaluatorRegistry.register(beh)
        }
        for (beh : this.behaviorsSkill.unregistrationWaiters) {
            this.evaluatorRegistry.unregister(beh)
        }
        this.schedulesSkill.runTasks
    }
}
</pre></div>

<h3 id="6-6-definition-of-the-time-skill">6.6. Definition of the Time skill</h3>

<p>The definition of the <code class="prettyprint">Time</code> built-in capacity is based on the delegation to the
tinyMAS time manager that is accessible from the agent owning the capacity.</p>

<div class="highlight highlight-SARL"><pre>
class TimeSkill extends Skill implements Time {
    def getTime(timeUnit : TimeUnit = null) : double {
        (owner as TMSarlAgent).getSimulationTime(timeUnit ?: TimeUnit::SECONDS)
    }
    def getOSTimeFactor : double {
        (owner as TMSarlAgent).getSimulationStepDuration(TimeUnit::SECONDS)
    }
}
</pre></div>

<h3 id="6-7-definition-of-the-externalcontextaccess-and-innercontextaccess-skills">6.7. Definition of the ExternalContextAccess and InnerContextAccess skills</h3>

<p>Because of a design choice, we have decided to no provide the implementation of the 
built-in capacities <code class="prettyprint">ExternalContextAccess</code> and <code class="prettyprint">InnerContextAccess</code>.</p>

<h2 id="7-creating-built-in-capacity-instances-in-the-agent">7. Creating built-in capacity instances in the agent</h2>

<p>Once the built-in capacity are implemented for the tinyMAS platform, we must implement
the built-in capacities&#39; instantiation and release.</p>

<h3 id="7-1-storing-the-built-in-capacities-in-agent-fields">7.1. Storing the built-in capacities in agent fields</h3>

<p>Because the built-in capacities&#39; instances exist during the whole life of the associated agent,
these instances must be stored in agent&#39;s fields.</p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends Agent implements EventListener {
    // [...]
    var behaviorSkill : BehaviorsSkill
    var loggingSkill : LoggingSkill
    var spaceSkill : DefaultContextInteractionsSkill
    var lifeSkill : LifecycleSkill
    var scheduleSkill : SchedulesSkill
    var timeSkill : TimeSkill
}
</pre></div>

<h3 id="7-2-initializing-the-agent-built-in-capacities">7.2. Initializing the agent built-in capacities</h3>

<p>For initializing the agent&#39;s built-in capacities, the <code class="prettyprint">start</code> function of the <code class="prettyprint">TMSarlAgent</code> type must be updated for:</p>

<ul>
<li>creating the built-in capacities&#39; instances; and</li>
<li>calling the <code class="prettyprint">setSkill</code> function on the SARL agent for setting the capacities.</li>
</ul>

<p>Calling the <code class="prettyprint">setSkill</code> function implies the call to the <code class="prettyprint">install</code> function of the skill.</p>

<p>The calls to the <code class="prettyprint">setSkill</code> function are done by using Java reflection because the
<code class="prettyprint">setSkill</code> function is a protected function in the SARL agent type. Retrieving the method
by reflection, and enabling the accessibility, allows to ignore the <code class="prettyprint">protected</code> modifier of
the <code class="prettyprint">setSkill</code> function.</p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends Agent implements EventListener {
    // [...]
    def start {
        super.start
        this.evaluatorRegistry.register(sarlAgent)
        this.behaviorSkill = new BehaviorsSkill
        this.loggingSkill = new LoggingSkill
        this.spaceSkill = new DefaultContextInteractionsSkill
        this.lifeSkill = new LifecycleSkill
        this.scheduleSkill = new SchedulesSkill
        this.timeSkill = new TimeSkill
        var method = typeof(io.sarl.lang.core.Agent).getDeclaredMethod("setSkill", typeof(Class), typeof(Skill))
        method.accessible = true
        method.invoke(sarlAgent, typeof(Behaviors), this.behaviorSkill)
        method.invoke(sarlAgent, typeof(Logging), this.loggingSkill)
        method.invoke(sarlAgent, typeof(DefaultContextInteractions), this.spaceSkill)
        method.invoke(sarlAgent, typeof(Lifecycle), this.lifeSkill)
        method.invoke(sarlAgent, typeof(Schedules), this.scheduleSkill)
        method.invoke(sarlAgent, typeof(Time), this.timeSkill)
        var initializeEvent = new Initialize(this.spawnerID, this.parameters)
        this.spawnerID = null
        this.parameters = null
        receiveEvent(initializeEvent)
    }
}
</pre></div>

<h3 id="7-3-uninstalling-the-agent-built-in-capacities">7.3. Uninstalling the agent built-in capacities</h3>

<p>For uninstalling the agent&#39;s built-in capacities, the <code class="prettyprint">stop</code> function of the <code class="prettyprint">TMSarlAgent</code> type
must be updated for calling the <code class="prettyprint">clearSkill</code> function on the SARL agent for uninstalling the capacities.</p>

<p>Calling the <code class="prettyprint">clearSkill</code> function implies the call to the <code class="prettyprint">uninstall</code> function of the skill.</p>

<p>The calls to the <code class="prettyprint">clearSkill</code> function are done by using Java reflection because the
<code class="prettyprint">clearSkill</code> function is a protected function in the SARL agent type. Retrieving the method
by reflection, and enabling the accessibility, allows to ignore the <code class="prettyprint">protected</code> modifier of
the <code class="prettyprint">clearSkill</code> function.</p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends Agent implements EventListener {
    // [...]
    def stop {
        receiveEvent(new Destroy)
        var method = typeof(io.sarl.lang.core.Agent).getDeclaredMethod("clearSkill", typeof(Class))
        method.accessible = true
        method.invoke(sarlAgent, typeof(Time))
        method.invoke(sarlAgent, typeof(Schedules))
        method.invoke(sarlAgent, typeof(Lifecycle))
        method.invoke(sarlAgent, typeof(DefaultContextInteractions))
        method.invoke(sarlAgent, typeof(Logging))
        method.invoke(sarlAgent, typeof(Behaviors))
        this.evaluatorRegistry.unregister(sarlAgent)
        super.stop
    }
}
</pre></div>

<h2 id="8-from-the-tinymas-proactive-message-ready-to-the-sarl-reactive-event-handling">8. From the tinyMAS proactive message ready to the SARL reactive event handling</h2>

<p>In the tinyMAs platform, agents are proactive for reading the messages they have received: the agents
call explicitely the functions for reading the messages.
In SARL, the agents are reactive regarding the event handling: the agents are automatically notified
when they received events.</p>

<p>It is mandatory to redefine the agent living function <code class="prettyprint">live</code> for mapping the proactive behavior of the
tinyMAS agents to the reactive behavior of the SARL agents.</p>

<p>The <code class="prettyprint">live</code> function loops on the content of the mailbox (<code class="prettyprint">while hasMessage</code>).
For each message, the function gets its content, and if it is a SARL event, the <code class="prettyprint">live</code> function
fires the event by calling the <code class="prettyprint">receiveEvent</code> function.</p>

<div class="highlight highlight-SARL"><pre>
class TMSarlAgent extends Agent implements EventListener {

    // [...]

    def live {
        for (beh : this.behaviorsSkill.registrationWaiters) {
            this.evaluatorRegistry.register(beh)
        }
        for (beh : this.behaviorsSkill.unregistrationWaiters) {
            this.evaluatorRegistry.unregister(beh)
        }

        while (hasMessage) {
            var message = nextMessage
            var content = message.content
            if (content instanceof Event) {
                receiveEvent(content)
            }
        }

        this.schedulesSkill.runTasks
    }

}
</pre></div>

<h2 id="9-booting-infrastructure">9. Booting infrastructure</h2>

<p>The next step for making tinyMAS a simple SARL run-time environment (SRE) is to define
the utility class for booting tinyMAS as a SRE. We define the <code class="prettyprint">Boot</code> class for supporting
the tinyMAS kernel booting.</p>

<p>As for the <a href="http://www.janusproject.io">standard SRE Janus</a>, we assume that 
the main entry point of the SRE expects the fully qualified name of the agent to launch as
the first command-line argument. the rest of the command-line arguments will be given as
initialization arguments to the launched agent.</p>

<h3 id="9-1-definition-of-the-main-entry-point">9.1. Definition of the main entry point</h3>

<p>We define the <code class="prettyprint">Boot</code> class with a main function as the SRE entry point. It extends the <code class="prettyprint">Kernel</code>
class provided by the tinyMAS platform for representing its kernel.</p>

<div class="highlight highlight-SARL"><pre>
class Boot extends Kernel {
    def static main(args : String[]) {
    }
}
</pre></div>

<h3 id="9-2-creation-of-the-sarl-default-context-and-space-instances">9.2. Creation of the SARL default context and space instances</h3>

<p>For creating an instance of the tinyMAS platform, three components must be created:</p>

<ul>
<li><code class="prettyprint">whitePages</code> for storing the running agents in the tinyMAS kernel;</li>
<li><code class="prettyprint">yellowPages</code> as the repository of the services provided by the tinyMAS agents; and</li>
<li><code class="prettyprint">mts</code> as the kernel service for routing the messages from a tinyMAS agent to another.</li>
</ul>

<p>The three tinyMAS components are defined and used for initializing:</p>

<ul>
<li>the SARL default space, named <code class="prettyprint">defaultSpace</code>,</li>
<li>the SARL default context, named <code class="prettyprint">context</code>, and</li>
<li>the tinyMAS kernel instance, named <code class="prettyprint">kernel</code>.</li>
</ul>

<p>The reference from the default space to the containing context must be manually set by invoking:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">defaultSpace.agentContext = context
</code></pre></div>
<p>The <code class="prettyprint">Boot</code> instance contains the default space as field, named <code class="prettyprint">defaultSpace</code>.
In the constructor of the <code class="prettyprint">Boot</code> class, the tinyMAS kernel identifier is given to the default space.
Indeed, the tinyMAS kernel identifier is known only when the tinyMAS kernel instance is created.</p>

<div class="highlight highlight-SARL"><pre>
class Boot extends Kernel {
    def static main(args : String[]) {
        var whitePages = new WhitePages
        var yellowPages = new YellowPages
        var mts = new MessageTransportService
        var defaultSpace = new TMDefaultSpace(whitePages, mts)

        var kernel = new Boot(defaultSpace, mts, whitePages, yellowPages)
        
        var context = new TMAgentContext(defaultSpace)
        defaultSpace.agentContext = context
    }
    val defaultSpace : TMDefaultSpace
    new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
            whitePages : WhitePages, yellowPages : YellowPages) {
        super(mts, whitePages, yellowPages)
        this.defaultSpace = defaultSpace
        this.defaultSpace.kernelID = kernelId
    }
}
</pre></div>

<h3 id="9-3-management-of-the-command-line-parameters">9.3. Management of the command-line parameters</h3>

<p>The main entry point must parse the command-line arguments for extracting
the fully qualified name of the agent to launch (named <code class="prettyprint">agentType</code>), and the
agent initialization parameters, named <code class="prettyprint">params</code>.</p>

<div class="highlight highlight-SARL"><pre>
class Boot extends Kernel {
    def static main(args : String[]) {
        var whitePages = new WhitePages
        var yellowPages = new YellowPages
        var mts = new MessageTransportService
        var defaultSpace = new TMDefaultSpace(whitePages, mts)

        var kernel = new Boot(defaultSpace, mts, whitePages, yellowPages)
        
        var context = new TMAgentContext(defaultSpace)
        defaultSpace.agentContext = context
        
        val agentName = args.get(0)
        var agentType = Class::forName(agentName)
        var params = Array.newInstance(typeof(Object), args.size - 1) as Object[]
        for (var i = 0; i < params.length; i++) {
            params.set(i, args.get(i + 1))
        }
    }
    val defaultSpace : TMDefaultSpace
    new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
            whitePages : WhitePages, yellowPages : YellowPages) {
        super(mts, whitePages, yellowPages)
        this.defaultSpace = defaultSpace
        this.defaultSpace.kernelID = kernelId
    }
}
</pre></div>

<h3 id="9-4-launching">9.4. Launching</h3>

<p>The launching process starts an agent by invoked the function <code class="prettyprint">spawn</code> of the utility class
<code class="prettyprint">Spawner</code>.</p>

<p>The <code class="prettyprint">spawn</code> function adds the agent into the registry of the agents, but it does not run the
tinyMAS platform. For running the tinyMAS platform, the <code class="prettyprint">run</code> function of the tinyMAS <code class="prettyprint">Kernel</code>
must be invoked.</p>

<div class="highlight highlight-SARL"><pre>
class Boot extends Kernel {
    def static main(args : String[]) {
        var whitePages = new WhitePages
        var yellowPages = new YellowPages
        var mts = new MessageTransportService
        var defaultSpace = new TMDefaultSpace(whitePages, mts)

        var kernel = new Boot(defaultSpace, mts, whitePages, yellowPages)
        
        var context = new TMAgentContext(defaultSpace)
        defaultSpace.agentContext = context
        
        val agentName = args.get(0)
        var agentType = Class::forName(agentName)
        var params = Array.newInstance(typeof(Object), args.size - 1) as Object[]
        for (var i = 0; i < params.length; i++) {
            params.set(i, args.get(i + 1))
        }
        if (typeof(io.sarl.lang.core.Agent).isAssignableFrom(agentType)) {
            Spawner.spawn(
                kernel,
                defaultSpace,
                agentType as Class<? extends io.sarl.lang.core.Agent>,
                null,
                TMDefaultSpace.TINYMAS_DEFAULT_SPACE_ID,
                null,
                params)
        }
        kernel.run
    }
    val defaultSpace : TMDefaultSpace
    new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
            whitePages : WhitePages, yellowPages : YellowPages) {
        super(mts, whitePages, yellowPages)
        this.defaultSpace = defaultSpace
        this.defaultSpace.kernelID = kernelId
    }
}
</pre></div>

<h2 id="10-general-events">10. General Events</h2>

<p>According to the SARL specification, a SARL run-time environment should fire specific platform-level events:</p>

<ul>
<li><code class="prettyprint">AgentSpawned</code> should be fired in the default space when an agent is created;</li>
<li><code class="prettyprint">AgentKilled</code> should be fired in the default space when an agent is killed;</li>
<li><code class="prettyprint">ContextJoined</code> should be fired in the agent when it has joint a context;</li>
<li><code class="prettyprint">ContextLeft</code> should be fired in the agent when it has left a context;</li>
<li><code class="prettyprint">MemberJoined</code> should be fired in the default space when an agent has joint a context;</li>
<li><code class="prettyprint">MemberLeft</code> should be fired in the default space when an agent has left a context.</li>
</ul>

<p>According to the design choice of supporting only one context and one interaction space, only
the <code class="prettyprint">AgentSpawned</code> and <code class="prettyprint">AgentKilled</code> must be really supported by the tinyMAS platform.</p>

<p>According to the tinyMAS specification, the only one way to determine when an agent is created or killed is
to register a specific event listener on the tinyMAS kernel.
Since this specific listener must exist during the entire life of the kernel, we register the listener
at the creation of the <code class="prettyprint">Boot</code> class.</p>

<p>Even for <code class="prettyprint">AgentSpawned</code> and <code class="prettyprint">AgentKilled</code>, the event firing follows the same steps:</p>

<ul>
<li>The source of the event is the tinyMAS platform, represented by the address with the default context identifier.</li>
<li>The created/destroyed agent&#39;s type is the type of the SARL agent or <code>null</code>.</li>
<li>The event is built from the computed information and the agent identifier given as parameter.</li>
<li>The event is fired in the default space.</li>
</ul>

<p>The obtained code is:</p>

<div class="highlight highlight-SARL"><pre>
class Boot extends Kernel {
    static class TinyMASKernelListener extends KernelAdapter {
        val containingBoot : Boot
        new(containingBoot : Boot) {
            this.containingBoot = containingBoot
        }
        def kernelAgentAdded(kernel : Kernel, ^agent : Agent, id : AgentIdentifier) {
            var source = new Address(
                    containingBoot.defaultSpace.spaceID,
                    TMDefaultSpace::TINYMAS_DEFAULT_SPACE_ID)
            var agentType : String
            if (^agent instanceof TMSarlAgent) {
                agentType = ^agent.sarlAgent.class.name
            } else {
                agentType = null
            }
            var spawnEvent = new AgentSpawned(source,
                    agentType,
                    Identifiers::toUUID(id))
            containingBoot.defaultSpace.emit(spawnEvent)
        }
        def kernelAgentRemoved(kernel : Kernel, ^agent : Agent, id : AgentIdentifier) {
            var source = new Address(
                    containingBoot.defaultSpace.spaceID,
                    TMDefaultSpace::TINYMAS_DEFAULT_SPACE_ID)
            var agentType : String
            if (^agent instanceof TMSarlAgent) {
                agentType = ^agent.sarlAgent.class.name
            } else {
                agentType = null
            }
            var spawnEvent = new AgentKilled(source,
                    Identifiers::toUUID(id),
                    agentType)
            containingBoot.defaultSpace.emit(spawnEvent)
        }
    }
    new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
            whitePages : WhitePages, yellowPages : YellowPages) {
        super(mts, whitePages, yellowPages)
        this.defaultSpace = defaultSpace
        this.defaultSpace.kernelID = kernelId
        addKernelListener(new TinyMASKernelListener(this))
    }
}
</pre></div>

<h2 id="11-finalizing-the-agent-spawning">11. Finalizing the agent spawning</h2>

<p>The agent spawning function defined in the <code class="prettyprint">TMDefaultSpace</code> type assumes the created agents are
buffered until their real addition into the tinyMAS platform.
Until this point of the document, we have not implemented the addition of the buffered agents
into the tinyMAS kernel.</p>

<p>According to the tinyMAS specification, the agents should be added at the end of each step
of the tinyMAS kernel. It is not possible to override a function for added a code at the end
of the tinyMAS kernel loop. Fortunately, each tinyMAs event listener is notified when
the tinyMAs kernel has finished its internal execution loop: the <code class="prettyprint">kernelRefreshAllowed</code> function
of the <code class="prettyprint">KernelListener</code> (or its <code class="prettyprint">KernelAdapter</code> implementation) is called.</p>

<p>We update the <code class="prettyprint">TinyMASKernelListener</code> inner class, which is defined in the previous section by
adding the definition of the <code class="prettyprint">kernelRefreshAllowed</code> function.</p>

<p>The <code class="prettyprint">kernelRefreshAllowed</code> function retrieves the buffered agents from the default space, by
invoking the <code class="prettyprint">consumeAgentToLaunch` function. Each agent replied by the</code>consumeAgentToLaunch<code class="prettyprint">
function is spawned in the tinyMAS platform by calling the</code>Spawner` utility class.</p>

<div class="highlight highlight-SARL"><pre>
def kernelRefreshAllowed(kernel : Kernel) {
    for (^agent : containingBoot.defaultSpace.consumeAgentToLaunch) {
        Spawner.spawn(kernel, ^agent)
    }
}
</pre></div>

<h2 id="12-update-of-the-jar-manifest-for-making-the-archive-as-a-sre">12. Update of the Jar Manifest for making the archive as a SRE</h2>

<p>Now, the code for making a SARL run-time environment (SRE) with the tinyMAS platform is ready.
For enabling the tinyMAS platform to be recognized as a SRE by the Eclipse SARL development
environment, the manifest file of the Jar archive of tinyMAs must contains mandatory information
that are explained in this section.</p>

<h3 id="12-1-definition-of-the-configuration-elements">12.1. Definition of the configuration elements</h3>

<p>The configuration elements for defining a SRE are:</p>

<table><thead>
<tr>
<th>Name</th>
<th>Explanation</th>
</tr>
</thead><tbody>
<tr>
<td>Main-Class</td>
<td>The fully qualified name of the main class of the program, usually the <code class="prettyprint">Boot</code> class that is previously defined.</td>
</tr>
<tr>
<td>SARL-Spec-Version</td>
<td>The version number of the SARL specification from which this SRE was created.</td>
</tr>
<tr>
<td>SRE-Name</td>
<td>The name of the SRE.</td>
</tr>
<tr>
<td>VM-Arguments</td>
<td>The arguments to pass to the Java virtual machine that will run the SRE.</td>
</tr>
<tr>
<td>Program-Arguments</td>
<td>The arguments to pass to the application, i.e. the launched agent.</td>
</tr>
<tr>
<td>Standalone-SRE</td>
<td>Indicates if the SRE&#39;s archive contains all the classes that are needed for running the SRE (if the value of Standalone-SRE is <code>true</code>), or if the SRE&#39;s archive contains only the SRE classes and not the dependency classes (if the value of Standalone-SRE is <code>false</code>).</td>
</tr>
<tr>
<td>CLI-Show-Logo</td>
<td>The command-line option to pass to the SRE for displaying the SRE logo at startup.</td>
</tr>
<tr>
<td>CLI-Hide-Logo</td>
<td>The command-line option to pass to the SRE for hiding the SRE logo at startup.</td>
</tr>
<tr>
<td>CLI-Show-Info</td>
<td>The command-line option to pass to the SRE for enabling information logging.</td>
</tr>
<tr>
<td>CLI-Hide-Info</td>
<td>The command-line option to pass to the SRE for disabling information logging.</td>
</tr>
<tr>
<td>CLI-Default-Context-ID</td>
<td>The command-line option to pass to the SRE for using the default context identifier.</td>
</tr>
<tr>
<td>CLI-Random-Context-ID</td>
<td>The command-line option to pass to the SRE for computing a random value for the default context identifier.</td>
</tr>
<tr>
<td>CLI-BootAgent-Context-ID</td>
<td>The command-line option to pass to the SRE for computing a value from the boot agent classname for the default context identifier.</td>
</tr>
<tr>
<td>CLI-Offline</td>
<td>The command-line option to pass to the SRE for disabling the network support (network is assumed to be on by default).</td>
</tr>
<tr>
<td>CLI-No-More-Option</td>
<td>The command-line option to pass to the SRE for indicating that the rest of the command-line arguments could not be command-line optoins (usually <code>--</code>).</td>
</tr>
<tr>
<td>CLI-Embedded</td>
<td>The command-line option to pass to the SRE for indicating to the SRE it is running inside the process of the Eclipse SARL development environment.</td>
</tr>
</tbody></table>

<h3 id="12-2-how-to-update-the-jar-manifest-by-hand">12.2. How to update the Jar Manifest by hand</h3>

<p>The previously defined configuration elements must appear inside the manifest file of the Jar archive of the
tinyMAS platform.</p>

<p>The <code>Main-Class</code> entry must appear in the main section of the manifest. For example,
the <code class="prettyprint">Boot</code> class that is defined in the previous sections of this document is the main class of the tinyMAS SRE.
It must be specified in the manifest file as:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Main-Class: org.arakhne.tinymas.sarl.Boot
</code></pre></div>
<p>The other configuration elements from the previous section must be specified in the manifest file in
a specific section, named <code>SARL-Runtime-Environment</code>.</p>

<p>The following manifest context gives an example of the tinyMAS SRE declaration:</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Main-Class: org.arakhne.tinymas.sarl.Boot

SARL-Runtime-Environment:
SRE-Name: TinyMAS
SARL-Spec-Version: 0.7
Standalone-SRE: true
VM-Arguments: -ea
Program-Arguments:
CLI-Show-Logo:
CLI-Hide-Logo:
CLI-Show-Info:
CLI-Hide-Info:
CLI-Default-Context-ID:
CLI-Hide-Info:
CLI-BootAgent-Context-ID:
CLI-Offline:
CLI-Embedded:
CLI-Hide-Info:
</code></pre></div>
<h3 id="12-3-maven-plugin-for-updating-the-manifest">12.3. Maven Plugin for Updating the Manifest</h3>

<p>The SARL project provides a <a href="http://maven.apache.org">Maven</a> plugin that enables the
SRE developer to update the manifest file automatically when the SRE project is built/compile (with Maven).</p>

<p>The Maven plugin is:</p>

<ul>
<li>GroupID: <code class="prettyprint">io.sarl.maven</code></li>
<li>ArtifactID: <code class="prettyprint">io.sarl.maven.sre</code></li>
</ul>

<p>The mojo action defined by the SRE Maven plugin is <code class="prettyprint">updatemanifest</code>. This mojo action
updates the existing manifest file with the SRE information.</p>

<p>The following XML code gives an example of Maven configuration that enables to use the SRE Maven plugin.</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;build&gt;</span>
    <span class="nt">&lt;plugins&gt;</span>
        <span class="nt">&lt;plugin&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>io.sarl.maven<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>io.sarl.maven.sre<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${sarl.version}<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;configuration&gt;</span>
                <span class="nt">&lt;sreName&gt;</span>TinyMAS<span class="nt">&lt;/sreName&gt;</span>
                <span class="nt">&lt;commandLineOptions&gt;</span>
                    <span class="nt">&lt;hideInfo&gt;&lt;/hideInfo&gt;</span>
                    <span class="nt">&lt;hideLogo&gt;&lt;/hideLogo&gt;</span>
                    <span class="nt">&lt;showInfo&gt;&lt;/showInfo&gt;</span>
                    <span class="nt">&lt;showLogo&gt;&lt;/showLogo&gt;</span>
                    <span class="nt">&lt;defaultContextId&gt;&lt;/defaultContextId&gt;</span>
                    <span class="nt">&lt;randomContextId&gt;&lt;/randomContextId&gt;</span>
                    <span class="nt">&lt;bootAgentContextId&gt;&lt;/bootAgentContextId&gt;</span>
                    <span class="nt">&lt;offline&gt;&lt;/offline&gt;</span>
                    <span class="nt">&lt;embedded&gt;&lt;/embedded&gt;</span>
                    <span class="nt">&lt;noMoreOption&gt;&lt;/noMoreOption&gt;</span>
                    <span class="nt">&lt;standaloneSRE&gt;</span>true<span class="nt">&lt;/standaloneSRE&gt;</span>
                <span class="nt">&lt;/commandLineOptions&gt;</span>
                <span class="nt">&lt;mainClass&gt;</span>org.arakhne.tinymas.sarl.Boot<span class="nt">&lt;/mainClass&gt;</span>
            <span class="nt">&lt;/configuration&gt;</span>

            <span class="nt">&lt;executions&gt;</span>
                <span class="nt">&lt;execution&gt;</span>
                    <span class="nt">&lt;id&gt;</span>update-manifest-standard<span class="nt">&lt;/id&gt;</span>
                    <span class="nt">&lt;goals&gt;</span>
                        <span class="nt">&lt;goal&gt;</span>updatemanifest<span class="nt">&lt;/goal&gt;</span>
                    <span class="nt">&lt;/goals&gt;</span>
                <span class="nt">&lt;/execution&gt;</span>
            <span class="nt">&lt;/executions&gt;</span>
        <span class="nt">&lt;/plugin&gt;</span>
    <span class="nt">&lt;/plugins&gt;</span>
<span class="nt">&lt;/build&gt;</span>
</code></pre></div>
<h2 id="13-configuration-of-a-sre-bootstrap">13. Configuration of a SRE Bootstrap</h2>

<p>An SRE bootstrap is a service that is provided by a SRE (here TinyMAS) for launching agents.</p>

<p>A bootstrap service is a well-known interface, named <code class="prettyprint">SREBootstrap</code> that enables to launch agents
programmatically without having a specific SRE library into the <em>compilation classpath</em> of your project.</p>

<p>The <code class="prettyprint">SREBootstrap</code> service provides the following functions:</p>

<div class="highlight highlight-SARL"><pre>
interface SREBootstrap {
    def [getBootAgentIdentifier](http://www.sarl.io) : UUID
    def [isActive](http://www.sarl.io) : boolean
    def [startAgent](http://www.sarl.io)(Class<Agent>, Object[]) : UUID
    def [startAgent](http://www.sarl.io)(int, Class<Agent>, Object[]) : Iterable<UUID>
    def [startWithoutAgent](http://www.sarl.io) : AgentContext
}
</pre></div>

<h3 id="13-1-configuration-by-hand">13.1. Configuration by hand</h3>

<p>A SRE library, e.g. <a href="../tools/Janus.html">Janus</a> may provide an implementation of the <code class="prettyprint">SREBootstrap</code> service.
In order to found this implementation dynamically, the SRE library should declare the bootstrap implementation class.
To do so, the file <code class="prettyprint">META-INF/services/io.sarl.core.SREBootstrap</code> must be created.
This file contains a single line, which is the fully qualified name of the bootstrap implementation class.</p>

<p>As soon the SRE library is included into the <em>run-time classpath</em>, the SRE utility class is able to find the
bootstrap implementation class. This SRE utility class is the major front-end for launching the agents programmatically.</p>

<h3 id="13-2-configuration-with-maven-plugin">13.2. Configuration with Maven plugin</h3>

<p>The above <code class="prettyprint">io.sarl.maven.sre</code> Maven plugin provides a tool for created the service definition.
First, you have to define the <code class="prettyprint">bootstrap</code> property with the fully qualified name of the bootstrap implementation class.
Second, you should run the <code class="prettyprint">addbootstrap</code> goal.
The resulting Mavne configuration becomes (after upadting the configuration above):</p>
<div class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;build&gt;</span>
    <span class="nt">&lt;plugins&gt;</span>
        <span class="nt">&lt;plugin&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>io.sarl.maven<span class="nt">&lt;/groupId&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>io.sarl.maven.sre<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;version&gt;</span>${sarl.version}<span class="nt">&lt;/version&gt;</span>
            <span class="nt">&lt;configuration&gt;</span>
                <span class="nt">&lt;sreName&gt;</span>TinyMAS<span class="nt">&lt;/sreName&gt;</span>
                <span class="nt">&lt;commandLineOptions&gt;</span>
                    <span class="nt">&lt;hideInfo&gt;&lt;/hideInfo&gt;</span>
                    <span class="nt">&lt;hideLogo&gt;&lt;/hideLogo&gt;</span>
                    <span class="nt">&lt;showInfo&gt;&lt;/showInfo&gt;</span>
                    <span class="nt">&lt;showLogo&gt;&lt;/showLogo&gt;</span>
                    <span class="nt">&lt;defaultContextId&gt;&lt;/defaultContextId&gt;</span>
                    <span class="nt">&lt;randomContextId&gt;&lt;/randomContextId&gt;</span>
                    <span class="nt">&lt;bootAgentContextId&gt;&lt;/bootAgentContextId&gt;</span>
                    <span class="nt">&lt;offline&gt;&lt;/offline&gt;</span>
                    <span class="nt">&lt;embedded&gt;&lt;/embedded&gt;</span>
                    <span class="nt">&lt;noMoreOption&gt;&lt;/noMoreOption&gt;</span>
                    <span class="nt">&lt;standaloneSRE&gt;</span>true<span class="nt">&lt;/standaloneSRE&gt;</span>
                <span class="nt">&lt;/commandLineOptions&gt;</span>
                <span class="nt">&lt;mainClass&gt;</span>org.arakhne.tinymas.sarl.Boot<span class="nt">&lt;/mainClass&gt;</span>
                <span class="nt">&lt;bootstrap&gt;</span>$org.arakhne.tinymas.sarl.Bootstrap<span class="nt">&lt;/bootstrap&gt;</span>
            <span class="nt">&lt;/configuration&gt;</span>

            <span class="nt">&lt;executions&gt;</span>
                <span class="nt">&lt;execution&gt;</span>
                    <span class="nt">&lt;id&gt;</span>update-manifest-standard<span class="nt">&lt;/id&gt;</span>
                    <span class="nt">&lt;goals&gt;</span>
                        <span class="nt">&lt;goal&gt;</span>updatemanifest<span class="nt">&lt;/goal&gt;</span>
                        <span class="nt">&lt;goal&gt;</span>addbootstrap<span class="nt">&lt;/goal&gt;</span>
                    <span class="nt">&lt;/goals&gt;</span>
                <span class="nt">&lt;/execution&gt;</span>
            <span class="nt">&lt;/executions&gt;</span>
        <span class="nt">&lt;/plugin&gt;</span>
    <span class="nt">&lt;/plugins&gt;</span>
<span class="nt">&lt;/build&gt;</span>
</code></pre></div>
<h2 id="14-legal-notice">14. Legal Notice</h2>

<ul>
<li>Specification: SARL General-purpose Agent-Oriented Programming Language (&quot;Specification&quot;)</li>
<li>Version: 0.7</li>
<li>Status: Draft Release</li>
<li>Release: 2017-10-23</li>
</ul>

<blockquote>
<p>Copyright &copy; 2014-2017 <a href="http://www.sarl.io/about/index.html">the original authors or authors</a>.</p>

<p>Licensed under the Apache License, Version 2.0;
you may not use this file except in compliance with the License.
You may obtain a copy of the <a href="http://www.apache.org/licenses/LICENSE-2.0">License</a>.</p>

<p>You are free to reproduce the content of this page on copyleft websites such as Wikipedia.</p>
</blockquote>

<p><small>Generated with the translator io.sarl.maven.docs.generator 0.7.0-SNAPSHOT.</small></p>

    </div> <!-- /default layout container -->

    <div class="container">
  <!-- FOOTER -->
  <footer>
    <div class="row">
      
    <div class="col-lg-3">
    <div class="well well-sm">
      
      <center>
      <h2>SARL</h2>
      <div>Agent-Oriented Programming Language</div>
      <img src="../../../images/SARL-logo.png" style="width:30%;max-width:64px;"/><br/>
      <small><a href="../../../images/SARL-logo.png">png</a>&nbsp;&middot;&nbsp;<a href="../../../images/SARL-logo.svg">svg</a></small>
      </center>
    </div>
    </div>
    <div class="col-lg-3">
      <div class="well well-sm">
      <h2><i class="glyphicon glyphicon-th-large"></i> Quick Links </h2> 
      <ul class="fa-ul">
		  <li>
			<a href="../../../news/index.html">
			  <i class="fa-li fa fa-feed"></i> News
			</a>
		  </li>
		  <li>
			<a href="../../../about/index.html">
			  <i class="fa-li fa fa-info"></i> About
			</a>
		  </li>
		  <li>
			<a href="../../../about/index.html#license">
			  <i class="fa-li fa fa-legal"></i> License
			</a>
		  </li>
      </ul>
      </div> 
    </div>
    <div class="col-lg-3">
      <div class="well well-sm">
      <h2><i class="glyphicon glyphicon-cog"></i> Support</h2>
      <ul class="fa-ul">
		  <li>
			<a href="../../../community/forums.html">
			  <i class="fa-li fa fa-comments"></i> User Forums
			</a>
		  </li>
		
		  <li>
			<a href="https://gitter.im/sarl/Lobby" target="_blank">
			  <i class="fa-li fa fa-wechat"></i> Chat Room
			</a>
		  </li>
		
		
		  <li>
			<a href="https://github.com/sarl/sarl" target="_blank">
			  <i class="fa-li fa fa-github"></i> GitHub
			</a>
		  </li>
		  <li>
			<a href="https://github.com/sarl/sarl/issues" target="_blank">
			  <i class="fa-li fa fa-bug"></i> Report an Issue
			</a>
		  </li>
		
		
		
		  <li>
			<a href="https://www.facebook.com/sarllanguage" target="_blank">
			  <i class="fa-li fa fa-facebook"></i> Facebook
			</a>
		  </li>
		
		
		
      </ul>
      </div> 
    </div>
    <div class="col-lg-3">
      <div class="well well-sm">
      <h2><i class="glyphicon glyphicon-link"></i> Links</h2>
      <ul class="fa-ul">
        <li><a href="http://www.janusproject.io" target="_blank"><i class="fa-li fa fa-gears"></i>Janus Project</a></li>
        <li><a href="http://www.gitia.org" target="_blank"><i class="fa-li fa fa-university"></i>GITIA - FRT - UTN</a></li>
        <li><a href="http://www.multiagent.fr" target="_blank"><i class="fa-li fa fa-university"></i>MAS Group - LE2I - UBFC</a></li>
      </ul>
      </div> 
    </div>
    </div>
    
  </footer>
</div>


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../../js/jquery.min.js"></script>
    <script src="../../../js/bootstrap.min.js"></script>
    <script src="../../../js/run_prettify.js"></script>
	<script src="../../../js/lang-sarl.js"></script>


	<!-- Google analystics -->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-106498978-1', 'auto');
	  ga('send', 'pageview');
	</script>

  </body>
</html>
