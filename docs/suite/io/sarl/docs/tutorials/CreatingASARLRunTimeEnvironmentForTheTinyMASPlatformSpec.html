<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="SARL is a general-purpose agent-oriented language.
SARL aims at providing the fundamental abstractions for dealing with concurrency, distribution, interaction, decentralization, reactivity, autonomy and dynamic reconfiguration. These high-level features are now considered as the major requirements for an easy and practical implementation of modern complex software applications. We are convinced that the agent-oriented paradigm holds the keys to effectively meet this challenge.
Considering the variety of existing approaches and meta-models in the field of agent-oriented engineering and more generally multi-agent systems, our approach remains as generic as possible and highly extensible to easily integrate new concepts and features. The language is platform- and architecture-independent.
">
    <meta name="author" content="SARL Team">
    <link rel="icon" href="../../../../../../images/favicon.ico" />
    <link rel="shortcut icon" href="../../../../../../images/favicon.ico">

    <title>Creating a SARL Run-time Environment for the tinyMAS platform</title>

    <link rel="stylesheet" href="../../../../../../css/bootstrap.min.css">
    <link rel="stylesheet" href="../../../../../../css/custom.css">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>

    

<!-- Fixed navbar -->
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://www.sarl.io">SARL</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li><a href="../../../../../../index.html">Home</a></li>
        <li><a href="../../../../../../docs/index.html">Documentation</a></li>
        <li><a href="../../../../../../download/index.html">Download</a></li>
        <li><a href="../../../../../../runtime/index.html">Run-time</a></li>
        <li><a href="../../../../../../community/index.html">Community</a></li>
        <li><a href="../../../../../../news/index.html">News &amp; Events</a></li>
        <li><a href="../../../../../../publications/index.html">Publications &amp; Presentations</a></li>
        <li><a href="../../../../../../about/index.html">About</a></li>
      </ul>
    </div><!--/.nav-collapse -->
  </div>
</div>

    <div class="container">
      <div class="tab-pane active" id="spec">
<p></p>
<ul class="page_outline" id="page_outline">
<li><a href="#SARL_and_tinyMAS_metamodels">1. SARL and tinyMAS metamodels</a></li>
<li><a href="#Mapping_of_the_identifiers">2. Mapping of the identifiers</a></li>
<li><a href="#Definition_of_the_default_context">3. Definition of the default context</a></li>
<li><a href="#Definition_of_the_default_space">4. Definition of the default space</a></li>
<li><a href="#First_definition_of_the_agent">5. First definition of the agent</a></li>
<li><a href="#Tool_for_spawning_agents">6. Tool for spawning agents</a></li>
<li><a href="#Definition_of_the_built_in_capacities">7. Definition of the built-in capacities</a></li>
<li><a href="#From_the_tinyMAS_proactive_message_ready_to_the_SARL_reactive_event_handling">8. From the tinyMAS proactive message ready to the SARL reactive event handling</a></li>
<li><a href="#Booting_infrastructure">9. Booting infrastructure</a></li>
<li><a href="#General_Events">10. General Events</a></li>
<li><a href="#Finalizing_the_agent_spawning">11. Finalizing the agent spawning</a></li>
<li><a href="#Update_of_the_Jar_Manifest_for_making_the_archive_as_a_SRE">12. Update of the Jar Manifest for making the archive as a SRE</a></li>
<li><a href="#Legal_Notice">13. Legal Notice</a></li>
</ul>
<p>This document describes how to create a SARL Run-time Environment (SRE) with the <a href="https://github.com/gallandarakhneorg/tinymas">tinyMAS platform</a>.</p>
<p>SRE executes or interprets compiled SARL code on an "hardware platform." The figure below illustrates the compilation process of a SARL program in which the run-time environment is involved.</p>
<p><img src="http://www.sarl.io/images/compilation-process.png" alt="SARL Generation Process"></p>
<p>The Tiny Multiagent Platform (tinyMAS) is a very small software platform, which permits to implement and run agent-based systems. This platform was written by Stéphane GALLAND and Nicolas GAUD for the multiagent courses of the Computer Science Department of the <a href="http://www.utbm.fr">Belfort-Montbéliard University of Technology</a>.</p>
<p>The purpose of this document is to describe the basics steps for making a SRE without changing the source code of neither the platform nor the SARL compiler. The tinyMAS SRE does not support all the elements of the SARL metamodel. Indeed the support for external contexts and inner contexts is not implemented.</p>
<p>Before reading this document, it is recommended reading the <a href="../reference/GeneralSyntaxReferenceSpec.html">General Syntax Reference</a>.</p>
<p></p>
<div class="bt-download"> <a href="https://github.com/gallandarakhneorg/tinymas"><img alt="Download the Source Code" src="http://www.sarl.io/images/download-icon.png"></a> </div> The elements that are explained in this tutorial are:
<ul>
  <li>the definition of the concepts from the SARL metamodel linked to the tinyMAS concepts;</li>
  <li>the definition of the definition of the boot process;</li>
  <li>the update of the manifest in order to make tinyMAS recognized as a SRE.</li>
</ul>
<p>The source code related to this tutorial may be found in the <a href="https://github.com/gallandarakhneorg/tinymas">tinyMAS Git repository</a>.</p>
<h3 id="SARL_and_tinyMAS_metamodels">1. SARL and tinyMAS metamodels</h3>
<p>The SARL language and the tinyMAS platform have been defined based on a collection of concepts that are formally described in their respective metamodels. This section gives a short overview of the two metamodels, and their possible links.</p>
<p>Defining the links between the SARL metamodel and the metamodel of the SRE is the first mandatory point for transforming the targeted platform to SRE.</p>
<h4 id="SARL_Metamodel">1.1. SARL Metamodel</h4>
<p>The SARL language is based on a collection of concepts that are described into its metamodel.</p>
<p><img src="./SARL_metamodel.png" alt="Part of the SARL Metamodel"></p>
<p>The key elements in the SARL metamodel are:</p>
<ul>
  <li>
<code>Context</code>: defines a set of interaction spaces in which agents are involved.</li>
  <li>
<code>Space</code>: or interaction space; defines a space in which interactions may occur.</li>
  <li>
<code>Address</code>: defines the identifiers of the agents in the interaction spaces.</li>
  <li>
<code>EventSpace</code>: defines a specific interaction space in which agents are interacting by firing and receiving events.</li>
  <li>
<code>Event</code>: defines an information/event that is exchanged by agents in an event space.</li>
  <li>
<code>Capacity</code>: defines a know-how of the agent; actions defines in a capacity could be invoked by the agent.</li>
  <li>
<code>Skill</code>: defines a specific implementation of a capacity. When a capacity's action is invoked by an agent, the corresponding implementation in the skill is called.</li>
  <li>
<code>Behavior</code>: defines a sub-part of the agent's behavior.</li>
  <li>Built-in capacities: the capacities that are known by the agents by default. The corresponding skills are provided by the run-time environment.</li>
</ul>
<h4 id="TinyMAS_Metamodel">1.2. TinyMAS Metamodel</h4>
<p>The tinyMAS platform is based on a collection of concepts that are described into its metamodel.</p>
<p><img src="./tinyMAS_metamodel.png" alt="Part of the tinyMAS Metamodel"></p>
<p>The key elements in the tinyMAS metamodel are:</p>
<ul>
  <li>
<code>AgentIdentifier</code>: defines the identifiers of the agents.</li>
  <li>
<code>Agent</code>: defines the concept of agent. Application agents must be defined in sub-classes.</li>
  <li>
<code>Message</code>: defines the base information exchanged by the agents.</li>
  <li>
<code>MessageTransportService</code> (and <code>AgentCommunicationChannel</code>): define the routing mechanism for the messages.</li>
  <li>
<code>MailboxManager</code>: defines a container of received messages for each agent.</li>
  <li>
<code>WhitePages</code>: defines a repository of all the agents in the system. It maps the agent identifiers to the agents.</li>
  <li>
<code>YellowPages</code>: defines a repository of services that could be provided by the agents. It maps the name of a service to a list of agent identifiers.</li>
  <li>
<code>Scheduler</code>: defines the agent execution policy.</li>
  <li>
<code>Kernel</code>: represents the entire tinyMAS platform.</li>
  <li>
<code>KernelListener</code>: describes an object that could be notified when a specific event occured in the tinyMAS kernel.</li>
</ul>
<h4 id="Linking_the_metamodels_concepts">1.3. Linking the metamodels' concepts</h4>
<p>The elements to define for creating a SRE are described in the following table. This table provides the mapping of these elements (several SARL concepts) to the corresponding implementation approach for tinyMAS.</p>
<p>The first column of the table gives the key point to consider for creating a SRE. The second column provides the key SARL concepts. And the third column describes the basics of the implementation for tinyMAS.</p>
<table class="table-bordered">
<thead>
<tr>
<th>SARL Element</th>
<th>SARL Concept</th>
<th>tinyMAS Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Identifying the agents</td>
			<td>`Address`</td>
			<td>tinyMAS provides the concept of `AgentIdentifier`.
				This identifier contains a reference to the kernel identifier, and
				the UUID of the agent. The SARL Address is for a specific interaction
				space. It contains the space identifier, and the UUID of the agent.
				For making the implementation simple, we assume that there is
				only the SARL default space available. The other spaces will not
				be supported by a tinyMAS implementation.</td>
</tr>
<tr>
<td>Agent abstraction</td>
			<td>`Agent`</td>
			<td>A specific implementation of the tinyMAS `Agent` should be coded.
				This implementation must have a reference to the SARL `Agent`.
				Additionally, the tinyMAS `Agent` will be the place to write
				the support for the agent life-cycle and the built-in capacities.</td>
</tr>
<tr>
<td>Exchanged information format for direct interaction</td>
			<td>`Event`</td>
			<td>The interaction in the tinyMAS platform is based on the concept of `Message`.
				tinyMAS provides all the features for routing and delivering the messages.
				Because the SARL agents are exchanging events by default, the tinyMAS
				cannot be directly delivered to the SARL agents. Linking the `Message`
				and `Event` concepts is done by considering that each `Event` occurrence
				must be enveloped by a `Message`, i.e. the content of a tinyMAS message
				is a SARL event.</td>
</tr>
<tr>
<td>Receiving SARL events</td>
			<td>Behavior units `on`</td>
			<td>A specific module in tinyMAS must be written for invoking the
				SARL behavior units on each SARL event that are in the received
				tinyMAS messages.</td>
</tr>
<tr>
<td>Default context definition</td>
			<td>`Context`</td>
			<td>In SARL, every agent exists in a context, named the default context.
				It is mandatory for tinyMAS to provide an implementation for the
				default context.</td>
</tr>
<tr>
<td>Default space definition</td>
			<td>`EventSpace`</td>
			<td>In SARL, every agent could interact through the default interaction
				space. It is mandatory for tinyMAS to provide an implementation for the
				default space.</td>
</tr>
<tr>
<td>Agent life-cycle</td>
			<td></td>
			<td>The agent life-cycle in tinyMAS is based on the calls to the functions
				`start` for initialization, `live` for running the agent behavior, and
				`end` for destroying the agent.
				The agent life-cycle in SARL is different. It is based on the receiving
				of events. The `Initialize` event represents the initialization of the agent.
				The `Destroy` event represents the agent destruction. The other events
				enable to create the agent behavior.
				Because the tinyMAS agent is the one that will be executed by tinyMAS,
				it is mandatory to generates the SARL events in the three tinyMAS life-cycle
				functions, a.k.a. `start`, `live`, `end`.</td>
</tr>
<tr>
<td>Managing platform events</td>
			<td>`AgentSpawned`, `AgentKilled`</td>
			<td>Several SARL events are assumed to be fired by the SRE. The two events
				that will be supported by tinyMAS are `AgentSpawned` for agent spawning,
				and `AgentKilled` for agent destruction.
				The other SARL platform events are ignored by tinyMAS, e.g. `ContextJoined`,
				`ContextLeft`, `MemberJoined`, `MemberLeft`.</td>
</tr>
<tr>
<td>Agent Spawning</td>
			<td>`spawn` functions</td>
			<td>A specific agent spawning function must be written for creating
				a tinyMAS agent that is embedding a SARL agent definition.
				This spawning functions will be invoked by the built-in capacities
				(see below).</td>
</tr>
<tr>
<td>Built-in capacity implementation</td>
			<td><a href="../reference/BuiltinCapacityReferenceSpec.html">BICs</a></td>
			<td>It is assumed that every SARL agent always contains the skills for a
			specific set of capacities, named the built-in capacities. These
			skills are supposed to be provided by the SRE.
			Consequently, each built-in capacity must have an implementation based
			on the tinyMAS features.</td>
</tr>
<tr>
<td>SRE Booting</td>
			<td></td>
			<td>An utility class for booting the tinyMAS SRE must be provided.
				Usually, this boot class takes the fully qualified name of the
				agent to launch, and the parameters to give to this agent.
				The boot class is supposed to set up the tinyMAS platform for
				being used as a SRE, and to launch SARL agents.</td>
</tr>
</tbody>
</table>
<h3 id="Mapping_of_the_identifiers">2. Mapping of the identifiers</h3>
<p><code>AgentIdentifier</code> in tinyMAS is based on a UUID and a reference to the identifier of the kernel. Because <code>AgentIdentifier</code> does not provide a function for retrieving the UUID, we should write an utility class for obtaining it.</p>
<p>The <code>AgentIdentifier</code> string representation contains the UUID, followed by a column character and the kernel identifier.</p>
<p>This utility class will be used for extracting the UUID of the tinyMAS agent identifier in order to create SARL address on the fly.</p>
<pre class="prettyprint lang-sarl linenums">final class Identifiers {

  static def toUUID(aid : AgentIdentifier) : UUID {
    val aidstr = aid.toString
    val index = aidstr.indexOf(":")
    return UUID::fromString(aidstr.substring(0, index))
  }

}</pre>
<h3 id="Definition_of_the_default_context">3. Definition of the default context</h3>
<p>A SARL Context defines the boundary of a sub-system, and gathers a collection of interaction Spaces. In each context, there is at least one particular space called the default space to which all agents in this context belong. This ensures the existence of a common shared space to all agents in the same context. </p>
<p>Each agent can then create specific public or private spaces to achieve its personal goals. Since their creation, agents are incorporated into a context called the default context.</p>
<p>The concept of context is not explicit in tinyMAS, i.e. all agents are evolving in the same and unique context.</p>
<p>Because SARL agents require to have access to the instance of the default context, a specific implementation must be provided upon the tinyMAS API.</p>
<h4 id="Definition_of_the_context_class">3.1. Definition of the context class</h4>
<p>A SARL context must be a class that is implementing the <code>AgentContext</code> type (provided in the SARL API).</p>
<pre class="prettyprint lang-sarl linenums">class TMAgentContext implements io.sarl.lang.core.AgentContext {
  // The code in the rest of this section will appear here
}</pre>
<h4 id="Definition_of_the_context_identifier">3.2. Definition of the context identifier</h4>
<p>A SARL context must have a unique identifier. We assume that only one context, the default context, will exist in the SARL applications ran with tinyMAS.</p>
<p>In order to retrieve easy the UUID of the default (root) context, we define the identifier as a public constant.</p>
<pre class="prettyprint lang-sarl linenums">public static val TINYMAS_AGENT_CONTEXT_ID = UUID::fromString("cdb0d568-4059-40cf-96c4-d078fee91cb1")

def getID : UUID {
  TINYMAS_AGENT_CONTEXT_ID
}</pre>
<h4 id="Declaration_of_the_default_space_of_the_context">3.3. Declaration of the default space of the context</h4>
<p>A SARL context has a default interaction space.</p>
<p>We declare the default space in the context class <code>TMAgentContext</code>. The concrete definition of the default space class named <code>TMDefaultSpace</code> is done later in this document.</p>
<pre class="prettyprint lang-sarl linenums">var defaultSpace : TMDefaultSpace

def getDefaultSpace : EventSpace {
  this.defaultSpace
}</pre>
<h4 id="Definition_of_the_getter_functions_for_spaces">3.4. Definition of the getter functions for spaces</h4>
<p>A SARL context provides a collection of functions for retrieving the spaces inside the context.</p>
<p>Please note that we assume that only one context will exist in the tinyMAS application. This context will be assumed to be the default context. In the same way, we assume that only one space (the default space) will exist in the default context.</p>
<p>Consequently, the function <code>getSpace()</code> replies the collection of all the context as an singleton collection instance that is containing the default space. This function must reply a auto-synchronized collection. We use the <code>Collections3</code> utility class, provided in the SARL API, for creating the synchronized collection. The first parameter of the <code>synchronizedCollection</code> function is the collection to synchronized, the second parameter is the object on from which the synchronization token will be obtained.</p>
<p>The <code>getSpaces(Class)</code> function is supposed to reply the existing spaces that were created by using the given type of space specification. Because of our assumption on the space singleton in the context, this function replies only the default space if the given space specification type is <code>EventSpaceSpecification</code>.</p>
<p>The <code>getSpace(UUID)</code> function replies the default space only if the given UUID is the identifier of the default space. In the other cases, the function replies nothing.</p>
<pre class="prettyprint lang-sarl linenums">def getSpaces : SynchronizedCollection&lt;? extends Space&gt; {
  Collections3::synchronizedCollection(Collections::singleton(this.defaultSpace), this)
}

def getSpaces(spec : Class&lt;? extends SpaceSpecification&lt;S&gt;&gt;)
    : SynchronizedCollection&lt;S&gt;
    with S extends Space {
  if (spec !== null &amp;&amp; spec == typeof(EventSpaceSpecification)) {
    return Collections3::synchronizedCollection(Collections::singleton(this.defaultSpace as S), this);
  }
  return Collections3::synchronizedCollection(Collections::emptyList, this)
}

def getSpace(spaceUUID : UUID) : S
     with S extends Space {
  if (spaceUUID == this.defaultSpace.spaceID.ID) {
    return this.defaultSpace as S
  }
  return null
}</pre>
<h4 id="Definition_of_the_creation_functions_for_spaces">3.5. Definition of the creation functions for spaces</h4>
<p>The context provides functions for creating spaces. Because we assume that no additional space could be created upon the tinyMAS SRE implementation, all these functions generates an "unsupported operation" exception.</p>
<pre class="prettyprint lang-sarl linenums">def createSpace(spec : Class&lt;? extends SpaceSpecification&lt;S&gt;&gt;,
    spaceUUID : UUID, creationParams : Object*)
    : S
    with S extends Space {
  throw new UnsupportedOperationException
}

def getOrCreateSpaceWithSpec(spec : Class&lt;? extends SpaceSpecification&lt;S&gt;&gt;,
    spaceUUID : UUID,creationParams : Object*)
    : S
    with S extends Space {
  throw new UnsupportedOperationException
}

def getOrCreateSpaceWithID(spaceUUID : UUID,
    spec : Class&lt;? extends SpaceSpecification&lt;S&gt;&gt;,
    creationParams : Object*)
    : S
    with S extends Space {
  throw new UnsupportedOperationException
}</pre>
<h4 id="Definition_of_the_constructor">3.6. Definition of the constructor</h4>
<p>The constructor of the agent context class must be defined for initializing the fields of the class.</p>
<p>The instance of the default space must be provided as parameter in order to set the <code>defaultSpace</code> field.</p>
<p>Additionally, the default space instance must be linked to the context (see the definition of the space class below). In the constructor, the <code>setAgentContext</code> is invoked on the default space.</p>
<pre class="prettyprint lang-sarl linenums">new (defaultSpace : TMDefaultSpace) {
  this.defaultSpace = defaultSpace
  this.defaultSpace.setAgentContext(this);
}</pre>
<h3 id="Definition_of_the_default_space">4. Definition of the default space</h3>
<p>The default space is the interaction space in which all the agents will be involved. Because we assume that only one agent context exists in the system, the default space becomes a singleton (only one default space could exist in a context).</p>
<h4 id="Definition_of_the_space_class">4.1. Definition of the space class</h4>
<p>A SARL default space must support an event-based interaction mechanism. Consequently, the default space class must implement the <code>EventSpace</code> interface that is provided by the SARL API.</p>
<pre class="prettyprint lang-sarl linenums">class TMDefaultSpace implements io.sarl.lang.core.EventSpace {
  // The code in the rest of this section will appear here
}</pre>
<h4 id="Definition_of_the_context_identifier">4.2. Definition of the context identifier</h4>
<p>A SARL space must have a unique identifier. We assume that only one context, the default context, will exist in the SARL applications ran with tinyMAS. Consequently, the default space instance becomes a singleton.</p>
<p>In order to retrieve easy the UUID of the default (root) context, we define the identifier as a public constant.</p>
<p>We defines the function <code>getSpaceID</code>, which is replying the space identifier.</p>
<p>The initialization of the <code>spaceID</code> field is not discussed yet, because the context identifier is mandatory for building the space identifier. The space identifier creation is discussed in the following section.</p>
<pre class="prettyprint lang-sarl linenums">public static val TINYMAS_DEFAULT_SPACE_ID = UUID::fromString("1db39309-8be7-4809-ad76-1ede6e792296")

var spaceID : SpaceID

def getSpaceID : SpaceID {
  this.spaceID
}</pre>
<h4 id="Linking_the_agent_context_to_the_space">4.3. Linking the agent context to the space</h4>
<p>We need to have a reference to the agent context that is containing this space in order to create the space identifier and to provide a reference to this context from the space.</p>
<p>Firstly, the reference to the agent context is declared as a weak reference field, named <code>context</code>.</p>
<p>The initialization of the <code>context</code> field is done by the <code>setAgentContext</code> function. As illustrated in the context definition section, this function is invoked when creating the agent context in order to be binded to its default space.</p>
<p>The space identifier is initialized in the <code>setAgentContext</code> because this is the place where the space's UUID and the context's identifier are known.</p>
<p>Finally, the getter function for retrieving the agent context is defined too.</p>
<pre class="prettyprint lang-sarl linenums">var context : WeakReference&lt;TMAgentContext&gt;

package def setAgentContext(context : TMAgentContext) {
  this.context = new WeakReference(context)
  this.spaceID = new SpaceID(context.ID, TINYMAS_DEFAULT_SPACE_ID, null)
}

def getAgentContext : TMAgentContext {
  this.context.get
}</pre>
<h3 id="First_definition_of_the_agent">5. First definition of the agent</h3>
<p>The next step is the definition of an abstraction for the SARL agent that could be executed as a tinyMAS agent. The easiest way to proceed is to create a tinyMAS agent class that has a reference to the SARL agent. Then, the specific tinyMAS agent implementation will map all the features from the tinyMAS platform to their equivalent features for the SARL agent.</p>
<h4 id="SARL_Agent_inside_tinyMAS_Agent">5.1. SARL Agent inside tinyMAS Agent</h4>
<p>We define a specific tinyMAS agent type, which is named <code>TMSarlAgent</code>. This agent definition contains a reference to the instance of the SARL agent definition, in the field <code>sarlAgent</code>. The getter of the SARL agent is also defined.</p>
<p>We define the <code>getID</code> function in order to easily retrieve the unique identifier of the agent. This unique identifier is the identifier of the SARL agent.</p>
<p>A constructor is defined for initializing the <code>sarlAgent</code> field.</p>
<p><caution>The constructor will be refined and redefined in the rest of this document.</caution></p>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends org.arakhne.tinyMAS.core.Agent {

  val sarlAgent : io.sarl.lang.core.Agent

  protected def getSarlAgent : io.sarl.lang.core.Agent {
    this.sarlAgent
  }

  def getID : UUID {
    this.sarlAgent.ID
  }

  new (sarlAgent : io.sarl.lang.core.Agent) {
    this.sarlAgent = sarlAgent
  }

}</pre>
<h4 id="Firing_SARL_events">5.2. Firing SARL events</h4>
<p>Event-based interaction is at the heart of the interaction mechanisms that could be used by the SARL agent. The <code>TMSarlAgent</code> class must provide tools for routing events when the basic interaction mechanism of tinyMAS is based on messages.</p>
<p>The first feature to implement is the firing/routing of SARL event. We define the <code>fireEvent</code> function that is extracting the SARL agent's behavior units (the <code>on</code> blocks of code), and is calling them with the event given as parameter.</p>
<p>Retrieving the SARL behavior unit is a algorithm that is following the SARL specifications. Fortunately, the SARL API provides an utility class for exploring the Java definition of an agent (by using the Java reflection mechanism), and providing the list of the behavior units that are taken a given event as input. The utility class is named <code>BehaviorGuardEvaluatorRegistry</code>. According to the SARL API, one instance of this registry may be created for each agent. Consequently, we created a final field named <code>evaluatorRegistry</code> that references the <code>BehaviorGuardEvaluatorRegistry</code> instance.</p>
<p>The first line of <code>fireEvent</code> retrieves the list of the behavior units that are defined in the SARL agent (and any internal behavior) for the given event.</p>
<p>The second part of the <code>fireEvent</code> function goes through the behavior units for evaluating there guards. The function <code>evaluateGuard</code> evaluates the guard of the behavior unit on the given event, and, if the guard is true, it fills the given list of handlers with a call to the behavior unit's code.</p>
<p>The third part of the <code>fireEvent</code> function invokes the behavior units' code that have a true guard.</p>
<pre class="prettyprint lang-sarl linenums">val evaluatorRegistry = new BehaviorGuardEvaluatorRegistry

package def fireEvent(^event : Event) {
  var evaluators = this.evaluatorRegistry.getBehaviorGuardEvaluators(^event)

  var handlers : Collection&lt;Runnable&gt; = new ArrayList
  for (evaluator : evaluators) {
    evaluator.evaluateGuard(^event, handlers);
  }

  for (handler : handlers) {
    handler.run();
  }
}</pre>
<h4 id="Registering_the_SARL_agent_as_behavior_unit_provider">5.3. Registering the SARL agent as behavior unit provider</h4>
<p>For enabling the <code>BehaviorGuardEvaluatorRegistry</code> instance to retrieve the behavior units of the SARL agent (and any internal behavior), we must register the SARL agent as a provider of behavior units to the <code>BehaviorGuardEvaluatorRegistry</code> instance.</p>
<p>The easier way to proceed is to register the SARL agent when the tinyMAS agent is starting; and to unregister the SARL agent when the tinyMAS agent is stopping. These two life-cycle functions are supported by the <code>start</code> and <code>stop</code> functions in the tinyMAS platform.</p>
<pre class="prettyprint lang-sarl linenums">def start {
  super.start
  this.evaluatorRegistry.register(getSarlAgent())
}

def stop {
  this.evaluatorRegistry.unregister(getSarlAgent())
  super.stop
}</pre>
<h4 id="Receiving_SARL_events">5.4. Receiving SARL events</h4>
<p>For enabling the receiving of SARL events, we need to define a specific SARL event listener. The easier way is to implement the <code>EventListener</code> interface from the SARL API (see the code below).</p>
<p>The implementation of the <code>EventListener</code> interface implies to implement the <code>receiveEvent</code> function. This function is called by the SARL infrastructure each time an event must be treated by the agent, i.e. when the agent receives the event.</p>
<p>The function <code>receiveEvent</code> calls the already implemented function <code>fireEvent</code>. Nevertheless, the <code>receiveEvent</code> function must ensure that the given event has a source, i.e. the address of the sender of the event. If the event has no source, the value of the source is forced to the address of the current SARL agent.</p>
<p>In order to create the address of the current agent, we must know the address of the agent in the default interaction space, and consequently, the default context in which the agent exists. We defined the <code>defaultSpace</code> field and the corresponds getter function for storing the default space of the agent. For initializing this field, we redefine the constructor.</p>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends org.arakhne.tinyMAS.core.Agent implements io.sarl.lang.core.EventListener {

  // [...]

  val defaultSpace : WeakReference&lt;TMDefaultSpace&gt;

  protected def getDefaultSpace : TMDefaultSpace {
    this.defaultSpace.get
  }

  def receiveEvent(^event : Event) {
    if (^event.source === null) {
      ^event.source = getDefaultSpace.getAddress(getSarlAgent.ID)
    }
    fireEvent(^event)
  }

  new (defaultSpace : TMDefaultSpace, sarlAgent : io.sarl.lang.core.Agent) {
    this.defaultSpace = new WeakReference(defaultSpace)
    this.sarlAgent = sarlAgent
  }

}</pre>
<h4 id="Initialize_and_Destroy_events">5.5. Initialize and Destroy events</h4>
<p>According to the SARL specification, two events must be fired for supporting the agents' life-cycle. The first event corresponds to the initialization of the agent, the <code>Initialize</code> event. And, the second event corresponds to the destruction of the agent, the <code>Destroy</code> event.</p>
<p>The tinyMAS implementation of the SRE must fire these two events according to the tinyMAS agent life-cycle. In this platform, the starting of the agents is supported by the <code>start</code> function. And the destruction of the agents is supported by the <code>stop</code> function.k</p>
<p>For firing the <code>Initialize</code> event, we need to create an instance of this event into the <code>start</code> function. But, from the SARL API documentation, the <code>Initialize</code> event must take the initialization parameters to pass to the agent at its start-up. For supporting these initialization parameters, we define the <code>parameters</code> field that is initialized in the agent type constructor. Then, the <code>start</code> function is updated for setting the parameters of the <code>Initialize</code> event; and for firing the event with a call to the <code>receiveEvent</code> function.</p>
<p>By symmetry, the <code>Destroy</code> event is initialize and fired in the <code>stop</code> function of the agent type.</p>
<pre class="prettyprint lang-sarl linenums">var spawnerID : UUID
var parameters : Object[]

new (defaultSpace : TMDefaultSpace, sarlAgent : io.sarl.lang.core.Agent, spawnerID : UUID, parameters : Object[]) {
  this.defaultSpace = new WeakReference(defaultSpace)
  this.sarlAgent = sarlAgent
  this.spawnerID = spawnerID
  this.parameters = parameters
}

def start {
  super.start
  this.evaluatorRegistry.register(getSarlAgent())
  
  var initializeEvent = new Initialize(this.spawnerID, this.parameters)
  this.spawnerID = null
  this.parameters = null
  receiveEvent(initializeEvent)
}

def stop {
  receiveEvent(new Destroy)
  this.evaluatorRegistry.unregister(getSarlAgent())
  super.stop
}</pre>
<h3 id="Tool_for_spawning_agents">6. Tool for spawning agents</h3>
<p>Spawning agents is a key feature of the execution platform. This feature is used for booting the initial agent, and by the agent built-in capacities for creating new agents.</p>
<p>In order to provide a reusable spawning function, we define the <code>Spawner</code> utility class that contains the static definition of the spawning functions of SARL agents on the tinyMAS platform.</p>
<h4 id="Creating_a_tinyMAS_agent_from_a_SARL_agent">6.1. Creating a tinyMAS agent from a SARL agent</h4>
<p>The first utility function that we define is <code>createAgent</code>. It enables to create an instance of <code>TMSarlAgent</code> from a SARL agent type.</p>
<p>The parameters of the functions are the ones required for building an instance of a SARL agent:</p>
<ul>
  <li>
<code>defaultSpace</code>: the instance of the default space in which the SARL agent will interact.</li>
  <li>
<code>agentType</code> : the type of SARL agent to create.</li>
  <li>
<code>spawerID</code> : the identifier of the agent's spanwer, or <code>null</code> if the platform has spawned the agent.</li>
  <li>
<code>parentID</code> : the identifier of the agent's parent, usually the identifier of the default context in the timeMAS SRE.</li>
  <li>
<code>agentID</code> : the identifier to give to the created agent, or <code>null</code> if the identifier must be randomly selected.</li>
  <li>
<code>params</code> : the initialization parameters to pass to the created SARL agent.</li>
</ul>
<p>The function replies the created tinyMAS agent that is binded to the SARL agent.</p>
<p>The code of the SARL agent creation is based on the call to the SARL agent constructor, as defined in the SARL specification. By default, the SARL agent agents have a constructor with three parameters:</p>
<ul>
  <li>first parameter of type <code>BuiltinCapacitiesProvider</code>: a provider of built-in capacity. Here we pass <code>null</code> as argument to the constructor in order to ignore the default initialization of the built-in capacities. This initialization will be done manually in one of the following sections.</li>
  <li>second parameter of type <code>UUID</code>: the identifier of the parent context of the created agent.</li>
  <li>third parameter of type <code>UUID</code>: the identifier of the created agent.</li>
</ul>
<p>The <code>createAgent</code> function should ensure the given agent type could be executed on the current instance of the tinyMAS platform. For that, we introduce two tests:</p>
<ul>
  <li>check if the given agent type is a sub-type of the <code>Agent</code> type provided in the SARL API; and</li>
  <li>use the <code>SarlSpecificationChecker</code> provided in the SARL API for verifying that the given agent type was generated with a SARL specification version that is compatible with the version supported by tinyMAS. We use the default implementation of the checker: <code>StandardSarlSpecificationChecker</code>.</li>
</ul>
<pre class="prettyprint lang-sarl linenums">static val SPECIFICATION_CHECKER : SarlSpecificationChecker = new StandardSarlSpecificationChecker

static def createAgent(
    defaultSpace : TMDefaultSpace, 
    agentType : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
    spawnerID : UUID,
    parentID : UUID,
    agentID : UUID,
    params : Object*)
    : TMSarlAgent {
  if (typeof(io.sarl.lang.core.Agent).isAssignableFrom(agentType)
    &amp;&amp; SPECIFICATION_CHECKER.isValidSarlElement(agentType)) {
    var theAgentID = if (agentID === null) UUID::randomUUID else agentID
    var theAgentType = agentType as Class&lt;? extends io.sarl.lang.core.Agent&gt;
    var cons = theAgentType.getConstructor(typeof(BuiltinCapacitiesProvider), typeof(UUID), typeof(UUID))
    var sarlAgent = cons.newInstance(null, parentID, theAgentID)
    var tmAgent = new TMSarlAgent(defaultSpace, sarlAgent, spawnerID, params)
    return tmAgent
  }
  return null
}</pre>
<h4 id="Launching_a_tinyMAS_SARL_agent_on_the_tinyMAS_kernel">6.2. Launching a tinyMAS-SARL agent on the tinyMAS kernel</h4>
<p>Now we have a function for creating a tinyMAS-SARL agent, it is necessary to provide an utility function for launching this tinnyMAS-SARL agent on the tinyMAS kernel.</p>
<p>We define the following <code>spawn</code> function thats takes as parameter the timasMAS kernel instance, and the agent to launch.</p>
<p>The function create the agent identifier of the agent in the tinyMAS platform, from the identifier of the kernel, and the SARL agent identifier.</p>
<p>Finally, the function invokes the agent launching function of the tinyMAS kernel. This function</p>
<pre class="prettyprint lang-sarl linenums">static def spawn(
    kernel : Kernel,
    ^agent : TMSarlAgent) {
  var tmid = new AgentIdentifier(kernel.kernelId, ^agent.ID.toString)
  kernel.addAgent(tmid, ^agent)
}</pre>
<h4 id="General_utility_function_for_spawning_agents">6.3. General utility function for spawning agents</h4>
<p>Now, we could define a general spawning function that invokes the two previously defined functions.</p>
<pre class="prettyprint lang-sarl linenums">static def spawn(
    kernel : Kernel,
    defaultSpace : TMDefaultSpace, 
    agentType : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
    spawnerID : UUID,
    parentID : UUID,
    agentID : UUID,
    params : Object*) : UUID {
  var ^agent = createAgent(defaultSpace, agentType, spawnerID, parentID, agentID, params)
  if (^agent !== null) {
    spawn(kernel, ^agent)
    return ^agent.ID
  }
  return null
}</pre>
<h3 id="Definition_of_the_built_in_capacities">7. Definition of the built-in capacities</h3>
<p>One of the key principle in the SARL specification is that each SARL agent is provided with a collection of built-in capacities that are provided by the run-time environment. In this section, we define the built-in capacities that are implemented with the tinyMAS API.</p>
<p><caution>In the following code, we assume that the given implementation is an inner class of the <code>TMSArlAgent</code> class. In this way, we will be able to access to the features of the agent type: <code>getId</code>, <code>getDefaultSpace</code>, <code>killMe</code>.</caution></p>
<h4 id="Definition_of_the_Logging_skill">7.1. Definition of the Logging skill</h4>
<p>The easiest built-in capacity to implement is the <code>Logging</code> capacity. This capacity enables the SARL agent to log messages on the output console.</p>
<p>The basic principle for implementing a built-in capacity is to create a class extending the <code>Skill</code> class, and implementing the capacity to implement, in this case the <code>Logging</code> capacity.</p>
<p>There is not particular issue with the coding of this buil-in capacity. The code is self-explaining.</p>
<pre class="prettyprint lang-sarl linenums">class LoggingSkill extends Skill implements Logging {

  def setLoggingName(message : String) {
    getId.stringRepresentation = message
  }

  def isErrorLogEnabled : boolean {
    true
  }

  def isWarningLogEnabled : boolean {
    true
  }

  def isInfoLogEnabled : boolean {
    true
  }

  def isDebugLogEnabled : boolean {
    true
  }

  def getLogLevel : int {
    0
  }

  def setLogLevel(level : int) {
  }


  def error(message : Object, exception : Throwable = null, parameters : Object*) {
    System::out.println("[" + getId.getString + "] ERROR: " + message)
    if (exception !== null) {
      exception.printStackTrace(System::out)
    }
  }

  def warning(message : Object, exception : Throwable = null, parameters : Object*) {
    System::out.println("[" + getId.getString + "] WARNING: " + message)
    if (exception !== null) {
      exception.printStackTrace(System::out)
    }
  }

  def info(message : Object, parameters : Object*) {
    System::out.println("[" + getId.getString + "] INFO: " + message)
  }

  def debug(message : Object, parameters : Object*) {
    System::out.println("[" + getId.getString + "] DEBUG: " + message)
  }

}</pre>
<h4 id="Definition_of_the_Lifecycle_skill">7.2. Definition of the Lifecycle skill</h4>
<p>The <code>Lifecycle</code> capacity is one of the must used capacity. It provides the support of the SARL agent life-cycle.</p>
<p>@filter(.* = '''|'''|.parseSuccessfully.*)</p>
<h5 id="Spawning_agents_in_the_default_space">7.2.1. Spawning agents in the default space</h5>
<p>Consider the agent execution mechanism in the tinyMAS platform: inside an infinite loop, each agent is run. This algorithmic principle may be described by the following algorithm:</p>
<pre class="prettyprint">       while (true) {
          for(a : whitePages.allAgents) {
             a.live
          }
          refreshKernelState
       }
</pre>
<p>The tinyMAS platform is designed for updating the kernel state after all the agent have been ran. Consequently, the tinyMAS platform does not support the creation of agents during the execution of another agent. If an agent spawns another agent, the real initialization of the spawned agent must be delayed until the <code>refreshKernelState</code> is invoked.</p>
<p>This particular design of the tinyMAS platform is at the opposite of the standard spawning principle in SARL: the agents are spawned when the spawning function is called.</p>
<p>For fixing this issue, we need to implement a buffer of spawned agents, that will be filled by the SARL spawning functions, and consumed by the <code>refreshKernelState</code> function.</p>
<p>The simplest place where to put this code in the <code>TMDefaultSpace</code> type. Indeed, we could assume that the agent spawning always occurs in the default space. We update the <code>TMDefaultSpace</code> class as described in the following code.</p>
<p>We define the <code>agentToLaunch</code> field as the spawn agent buffer.</p>
<p>The <code>spawn</code> function creates the agent instance, based on the <code>Spawner</code> utility class, and adds the created agent into the buffer.</p>
<p>The consumption of the spawn agent buffer is supported by the <code>consumeAgentToLaunch</code> function. This function replies the buffer content, and clears the buffer.</p>
<pre class="prettyprint lang-sarl linenums">var agentsToLaunch : List&lt;TMSarlAgent&gt; = new ArrayList

def spawn(
    anAgent : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
    spawnerID : UUID,
    agentID : UUID,
    params : Object*)
    : UUID {
  val ^agent = Spawner::createAgent(
      this,
      anAgent,
      spawnerID,
      TINYMAS_DEFAULT_SPACE_ID,
      agentID,
      params)
  this.agentsToLaunch += ^agent
  return ^agent.ID
}

def consumeAgentToLaunch : Iterable&lt;TMSarlAgent&gt; {
  var iterable = this.agentsToLaunch
  this.agentsToLaunch = new ArrayList
  return iterable
}</pre>
<h5 id="First_definition_of_the_skill">7.2.2. First definition of the skill</h5>
<p>The functions for spawning the agents delegate the spawning to the default space (as defined in the previous section).</p>
<p>The <code>killMe</code> function enables to stop the agent which is invoking this function. The agent killing is delegated to the tinyMAS agent killing function, also named <code>killMe</code>. The <code>owner</code> is a syntactic simplification of a call to <code>getOwner</code>, which replies the agent owning the skill.</p>
<p>One important point regarding the expected behavior of the SARL <code>killMe</code> is that is must never return from the point of view of its caller. For simulating this behavior, we could use the exception mechanism by throwing a specific internal exception that is not a real error but represents the "no-return code" case. This specific exception is named <code>NoReturnCodeException</code>, and is defined in the next section.</p>
<pre class="prettyprint lang-sarl linenums">class LifecycleSkill extends Skill implements Lifecycle {

  def spawn(
      agentClass : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
      params : Object*)
      : UUID {
    return defaultSpace.spawn(agentClass, null, params)
  }

  def spawn(
      nbAgents : int,
      agentClass : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
      params : Object*)
      : Collection&lt;UUID&gt; {
    var list = newArrayList
    for (i : 1..nbAgents) {
      var id = defaultSpace.spawn(agentClass, null, params)
      if (id !== null) {
        list += id
      }
    }
    return list
  }

  def spawnInContext(
      agentClass : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
      context : AgentContext,
      params : Object*)
      : UUID {
    if (context.ID == defaultSpace.agentContext.ID) {
      return defaultSpace.spawn(agentClass, owner.ID, null, params)
    }
    return null
  }

  def spawnInContext(
      nbAgents : int,
      agentClass : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
      context : AgentContext,
      params : Object*)
      : Collection&lt;UUID&gt; {
    var list = newArrayList
    if (context.ID == defaultSpace.agentContext.ID) {
      for (i : 1..nbAgents) {
        var id = defaultSpace.spawn(agentClass, null, params)
        if (id !== null) {
          list += id
        }
      }
    }
    return list
  }

  def spawnInContextWithID(
      agentClass : Class&lt;? extends io.sarl.lang.core.Agent&gt;,
      agentID : UUID,
      context : AgentContext,
      params : Object*)
      : UUID {
    if (context.ID == defaultSpace.agentContext.ID) {
      return defaultSpace.spawn(agentClass, owner.ID, agentID, params)
    }
    return null
  }

  def killMe {
    (owner as TMSarlAgent).killMe
    throw new NoReturnCodeException
  }

}</pre>
<h5 id="Support_of_the_no_return_functions">7.2.3. Support of the no-return functions</h5>
<p>The exception that is simulating a no-return-code is defined as:</p>
<pre class="prettyprint lang-sarl linenums">class NoReturnCodeException extends RuntimeException {
}</pre>
<h5 id="Catching_the_no_return_code_exception">7.2.4. Catching the no-return-code exception</h5>
<p>For avoiding the tinyMAS platform to stop because the <code>NoReturnCodeException</code> was not caught, we must redefined the <code>fireEvent</code> function in the <code>TMSarlAgent</code> type. Indeed, this function is the one which is running the code of the SARL event handlers in which the SARL <code>killMe</code> function could be invoked.</p>
<p>Each call to a piece of SARL code is enclosing by a try-catch statement that is simply ignoring the <code>NoReturnCodeException</code> exception.</p>
<pre class="prettyprint lang-sarl linenums">package def fireEvent(^event : Event) {
  var evaluators = this.evaluatorRegistry.getBehaviorGuardEvaluators(^event)

  var handlers : Collection&lt;Runnable&gt; = new ArrayList
  for (evaluator : evaluators) {
    try {
      evaluator.evaluateGuard(^event, handlers);
    } catch (e : NoReturnCodeException) {
    }
  }

  for (handler : handlers) {
    try {
      handler.run()
    } catch (e : NoReturnCodeException) {
    }
  }
}</pre>
<h4 id="Definition_of_the_DefaultContextInteractions_skill">7.3. Definition of the DefaultContextInteractions skill</h4>
<p>The <code>DefaultContextInteractions</code> capacity enables the agent to have interaction in the default space.</p>
<h5 id="First_definition_of_the_skill">7.3.1. First definition of the skill</h5>
<p>The first and incomplete definition of the <code>DefaultContextInteractions</code> capacity for the tinyMAS platform is provided below.</p>
<p>The functions that replies the default context and the default space are defined for replying the context and space that are referenced in the agent. The <code>owner</code> is a syntactic simplification of a call to <code>getOwner</code>, which replies the agent owning the skill.</p>
<p>The <code>getAddress</code> function replies the address of the owner in the default space. Its behavior is delegated to the <code>getAddress(UUID)</code> of the default space.</p>
<p>The <code>isDefaultContext</code> functions implemented in order to test if their parameters correspond to the default context.</p>
<p>Similarly, the <code>isDefaultSpace</code> functions are implemented in order to test if their parameters correspond to the default space.</p>
<p>The <code>isInDefaultSpace</code> function replies <code>true</code> if the given event is fired into the default space. The function behavior is delegated to the <code>isDefaultSpace</code> function with the event source identifier as argument.</p>
<pre class="prettyprint lang-sarl linenums">class DefaultContextInteractionsSkill extends Skill implements DefaultContextInteractions {

  def getDefaultContext : AgentContext {
    ((owner as TMSarlAgent).defaultSpace as TMDefaultSpace).agentContext
  }

  def getDefaultSpace : EventSpace {
    (owner as TMSarlAgent).defaultSpace
  }

  def getDefaultAddress : Address {
    var o = owner as TMSarlAgent
    o.defaultSpace.getAddress(o.sarlAgent.ID)
  }

  def isDefaultContext(context : AgentContext) : boolean {
    context.ID == (defaultSpace as TMDefaultSpace).agentContext.ID
  }

  def isDefaultContext(contextID : UUID) : boolean {
    contextID == (defaultSpace as TMDefaultSpace).agentContext.ID
  }

  def isDefaultSpace(^space : Space) : boolean {
    ^space.ID == defaultSpace.spaceID
  }

  def isDefaultSpace(^space : SpaceID) : boolean {
    ^space == defaultSpace.spaceID
  }

  def isDefaultSpace(^space : UUID) : boolean {
    ^space == defaultSpace.spaceID.ID
  }

  def isInDefaultSpace(^event : Event) : boolean {
    isDefaultSpace(^event.source.spaceId)
  }

}</pre>
<h5 id="Firing_events_in_the_default_space">7.3.2. Firing events in the default space</h5>
<p>Firing events in the default space could be done by calling the <code>emit</code> and <code>willReceive</code> functions.</p>
<p>The <code>emit</code> function fires the given event into the default space. Optionally, a scope could be provided for restricting the set of the event's receivers. The <code>emit</code> function delegates its behavior to the <code>emit</code> function of the default space.</p>
<p>One import point in the implementation of the <code>emit</code> function is the check of the event's source. Indeed, sometimes, the given event has no source address set. Because the default space could not set this address when it is <code>null</code>, we must check this case and force the value of the event source address to the address of the current agent.</p>
<p>The <code>willReceive</code> function is a inverted version of the syntactic call to the firing function. This function enables the developer to send the event to a specific agent with the following syntax: <code>
receverID.willReceive(^event)
</code></p>
<pre class="prettyprint lang-sarl linenums">def emit(^event : Event, scope : Scope&lt;Address&gt; = null) {
  if (^event.source === null) {
    ^event.source = defaultSpace.getAddress(owner.ID)
  }
  defaultSpace.emit(^event, scope)
}

def willReceive(receiver : UUID, ^event : Event) {
  emit(^event, Scopes::addresses(defaultSpace.getAddress(receiver)))
}</pre>
<h5 id="Spawning_agents_in_the_default_context">7.3.3. Spawning agents in the default context</h5>
<p>Spawning an agent in the default context could be done by calling the <code>spawn</code> function of the <code>DefaultContextInteractions</code> capacity. This function delegates its behavior to the <code>spawn</code> function that is already defined in the tinyMAS-SARL default space class.</p>
<pre class="prettyprint lang-sarl linenums">def spawn(agentType : Class&lt;? extends io.sarl.lang.core.Agent&gt;, params : Object*) : UUID {
  (defaultSpace as TMDefaultSpace).spawn(agentType, owner.ID, null, params)
}</pre>
<h4 id="Definition_of_the_Behaviors_skill">7.4. Definition of the Behaviors skill</h4>
<p>The <code>Behaviors</code> capacity enables the agent to have sub-behaviors that could be dynamically added and removed.</p>
<h5 id="First_definition_of_the_skill">7.4.1. First definition of the skill</h5>
<p>The first and incomplete definition of the <code>Behaviors</code> capacity for the tinyMAS platform is provided below.</p>
<p>The first function implemented is the <code>asEventListener</code> function. It replies the object that could serve as a SARL event listener for the agent. In the tinyMAS implementation, we have already implemented the <code>EventListener</code> interface in the <code>TMSarlAgent</code> class. In other word, the tinyMAS agent type is already a SARL event listener by itself. Consequently, the <code>asEventListener</code> function replies the owner of the skill, i.e. the agent.</p>
<pre class="prettyprint lang-sarl linenums">class BehaviorsSkill extends Skill implements Behaviors {
  
  def asEventListener : EventListener {
    owner as TMSarlAgent
  }

}</pre>
<h5 id="Registering_a_behavior">7.4.2. Registering a behavior</h5>
<p>A <code>Behavior</code> instance could be registered in order to be run for the current agent. The <code>registerBehavior</code> function enables the SARL developer to add a <code>Behavior</code> instance into the registered sub-behaviors of the agent.</p>
<p>In order to store the list of the sub-behavior, we must define the <code>behaviors</code> field. The content of this field is increased by the <code>registerBehavior</code> function.</p>
<pre class="prettyprint lang-sarl linenums">val behaviors : List&lt;Behavior&gt; = new ArrayList

def registerBehavior(attitude : Behavior) : Behavior {
  if (attitude !== null) {
    this.behaviors += attitude
  }
  return attitude
}</pre>
<h5 id="Unregistering_a_behavior">7.4.3. Unregistering a behavior</h5>
<p>The <code>unregisterBehavior</code> function enables the SARL developer to remove a <code>Behavior</code> instance from the registered sub-behaviors of the agent. The content of the <code>behaviors</code> field defined in the previous section is decreased with the given attitude.</p>
<pre class="prettyprint lang-sarl linenums">def unregisterBehavior(attitude : Behavior) : Behavior {
  if (attitude !== null) {
    this.behaviors -= attitude
  }
  return attitude
}</pre>
<h5 id="Waking_the_behaviors_with_an_event">7.4.4. Waking the behaviors with an event</h5>
<p>The SARL specification indicates that it is possible for an agent to fire an event inside its internal context. In other words, the event will be received by the agent, and its internal behaviors, and not by the other agents.</p>
<p>The <code>wake</code> function is provided for supporting this feature. Its implementation retrieves the SARL event listener of the agent by calling the <code>asEventListener</code> function. And, it invokes the receiving function of the listener with the event as argument.</p>
<p>If a scope is provided, it must be used for filtering the receivers which have an address. In the context of the tinyMAS platform, only the agent fits this requirement. Consequently, the scope is matched against the agent's address in its internal context (not the agent's address in the default space of its default context). The <code>getInnerAddress</code> function computes the agent's address in the agent internal context.</p>
<pre class="prettyprint lang-sarl linenums">def wake(^event : Event, scope : Scope&lt;Address&gt; = null) {
  if (scope === null || scope.matches(innerAddress)) {
    asEventListener.receiveEvent(^event)
  }
}

private def getInnerAddress : Address {
  var id = (owner as TMSarlAgent).ID
  return new Address(
      new SpaceID(id, UUID.randomUUID, typeof(EventSpaceSpecification)),
      id)
}</pre>
<h5 id="Accessing_to_the_collection_of_the_registered_behaviors">7.4.5. Accessing to the collection of the registered behaviors</h5>
<p>Two functions must be implemented for accessing to the internal list of the behaviors: </p>
<ul> <li>
<code>hasRegisteredBehavior</code> indicates if a behavior is registered; and</li> <li>
<code>getRegisteredBehaviors</code> replies an unmodifiable collection of the registered behaviors.</li> </ul>
<pre class="prettyprint lang-sarl linenums">def hasRegisteredBehavior : boolean {
  !this.behaviors.isEmpty
}

def getRegisteredBehaviors : Collection&lt;Behavior&gt; {
  new ArrayList(this.behaviors)
}</pre>
<h5 id="Updating_the_tinyMAS_agent_life_cycle_for_un_registering_the_behaviors">7.4.6. Updating the tinyMAS agent life-cycle for [un]registering the behaviors</h5>
<p>There is an key difference between the SARL run-time principle, which is fully distributed (everything is registered, run, unregistered in parallel), and the tinyMAS run-time principle, which is fully sequential (everything is controlled in a big virtual loop). Consequently, it is mandatory to map the fully-distributed point-of-view from the SARL specification to the sequential point-of-view from tinyMAS.</p>
<h6 id="Defining_buffers_of_behaviors">7.4.6.1. Defining buffers of behaviors</h6>
<p>In order to map the SARL behavior support to tinyMAS platform, the <code>BehaviorsSkill</code> type must store the registered and unregistered behaviors separately. Indeed, the registered behaviors must become SARL event listeners in the agent context. And, the unregistered behaviors must be SARL event listener anymore.</p>
<p>In order to separate these two subsets of behaviors, we define the two fields <code>registrationWaiters</code> and <code>unregistrationWaiters</code>, which represent the behaviors that are waiting for event listening registration, and event listener unregistration, respectively.</p>
<p>We define the <code>getRegistrationWaiters</code> and <code>getUnregistrationWaiters</code> functions for replying and consuming these subsets. These functions will be invoked later, from the tinyMAS agent living function.</p>
<pre class="prettyprint lang-sarl linenums">var registrationWaiters : List&lt;Object&gt; = new ArrayList

var unregistrationWaiters : List&lt;Object&gt; = new ArrayList

def getRegistrationWaiters : Iterable&lt;Object&gt; {
  val collection = this.unregistrationWaiters
  this.unregistrationWaiters = new ArrayList
  return collection
}

def getUnregistrationWaiters : Iterable&lt;Object&gt; {
  val collection = this.registrationWaiters
  this.registrationWaiters = new ArrayList
  return collection
}</pre>
<h6 id="Updating_the_buffers_of_behaviors">7.4.6.2. Updating the buffers of behaviors</h6>
<p>The <code>registerBehavior</code> and <code>unregisterBehavior</code> functions that are already defined in the <code>BehaviorsSkill</code> type must be redefined in order to include the updating of the behavior's buffers.</p>
<p>In the <code>registerBehavior</code> function, the registering attitude (behavior) is added into the set of behaviors that are waiting for SARL event listening registration.</p>
<p>The registering attitude is also remove from the set of behaviors that are waiting for SARL event listening unregistration. It avoids to have registration and unregistration at the same time for the same attitude.</p>
<p>In the <code>unregisterBehavior</code> function, the unregistering attitude (behavior) is added into the set of behaviors that are waiting for SARL event listening unregistration. And, it is removed from the set of whose waiting for registration.</p>
<pre class="prettyprint lang-sarl linenums">def registerBehavior(attitude : Behavior) : Behavior {
  if (attitude !== null) {
    this.behaviors += attitude
    this.registrationWaiters += attitude
    this.unregistrationWaiters -= attitude
  }
  return attitude
}

def unregisterBehavior(attitude : Behavior) : Behavior {
  if (attitude !== null) {
    this.behaviors -= attitude
    this.registrationWaiters -= attitude
    this.unregistrationWaiters += attitude
  }
  return attitude
}</pre>
<h6 id="Updating_the_tinyMAS_agent_living_function">7.4.6.3. Updating the tinyMAS agent living function</h6>
<p>In order to map the (un)registered the SARL behaviors at the correct instant during the tinyMAS agent life-cycle, we must define the agent living function (<code>live</code>) in the <code>TMSarlAgent</code> type.</p>
<p>We assume that the <code>behaviorsSkill</code> field is defined and set (Section <a href="#Creating_built-in_capacity_instances_in_the_agent">Creating built-in capacity instances in the agent</a> explains how to proceed). This field contains a reference to the <code>BehaviorsSkill</code> skill owned by the agent.</p>
<p>We assume that the <code>evaluatorRegistry</code> field is defined, and contains a reference to the <code>BehaviorGuardEvaluatorRegistry</code> instance that is used for managing the agent event bus (see the previous sections for its definition).</p>
<p>The <code>live</code> function is implemented in order to retrieve the behaviors, which are waiting for SARL event listening (un)registration. For each behavior, the (un)registration function on the <code>BehaviorGuardEvaluatorRegistry</code> instance is called.</p>
<p>Putting this code in the <code>live</code> function ensures that the agent's behaviors are (un)registered at the beginning of each step of the agent's life, and not in parallel to the other agent's tasks.</p>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends Agent implements EventListener {

  // [...]

  var behaviorsSkill : BehaviorsSkill

  def live {
    for (beh : this.behaviorsSkill.registrationWaiters) {
      this.evaluatorRegistry.register(beh)
    }
    for (beh : this.behaviorsSkill.unregistrationWaiters) {
      this.evaluatorRegistry.unregister(beh)
    }
  }

}</pre>
<h6 id="Proper_un_installation_of_the_skill">7.4.6.4. Proper un-installation of the skill</h6>
<p>Because a skill could be dynamically removed from an agent, we must unregister each agent's behavior when the skill is uninstalled.</p>
<p>In the <code>BehaviorsSkill</code> type, we define the <code>uninstall</code> function, which is automatically invoked when the skill is removed from the agent.</p>
<p>The code of the <code>uninstall</code> function goes through all the behaviors, and invokes the <code>unregister</code> function of the agent's event bus with each of them as argument.</p>
<pre class="prettyprint lang-sarl linenums">protected def uninstall(stage : UninstallationStage) {
  switch (stage) {
  case PRE_DESTROY_EVENT: {
    }
  case POST_DESTROY_EVENT: {
      for (beh : this.behaviors) {
        (owner as TMSarlAgent).evaluatorRegistry.unregister(beh)
      }
    }
  }
}</pre>
<h4 id="Definition_of_the_Schedules_skill">7.5. Definition of the Schedules skill</h4>
<p>The <code>Schedules</code> capacity enables the agent to run periodic and not-periodic tasks.</p>
<h5 id="Definition_of_the_synchronous_agent_task_type">7.5.1. Definition of the synchronous agent task type</h5>
<p>The SARL <code>AgentTask</code> type represents a task for the SARL agents. The default implementation of <code>AgentTask</code> assumes that the task will be run asynchronously (usually with a Java thread execution pool).</p>
<p>Unfortunately, the tinyMAS platform forbids to use a thread execution pool because of its internal design specification: the tintMAS platform execution mechanism is synchronous.</p>
<p>In order to run an <code>AgentTask</code> on tinyMAS, we must define a subtype, named <code>Task</code> that is providing the features, which are usually given by the Java thread execution pool: </p>
<ul> <li>cancellation of the task,</li> <li>period of execution of the task.</li>
<li> </li>
</ul>
<pre class="prettyprint lang-sarl linenums">class Task extends AgentTask {

  var isCanceled = false
  
  var period = 0l
  
  def isCanceled : boolean {
    this.isCanceled
  }
  
  def cancel {
    this.isCanceled = true
  }
  
  def getPeriod : long {
    this.period
  }
  
  def setPeriod(period : long) {
    this.period = period
  }

}</pre>
<h5 id="First_definition_of_the_skill">7.5.2. First definition of the skill</h5>
<p>The first and incomplete definition of the <code>SchedulesSkill</code> type is described below. This type is the tinyMAS implementation of the <code>Schedules</code> capacity.</p>
<p>The <code>task</code> function enables to create a SARL task with the given name. The implementation creates the task instance, and sets the name of the task with a unique value.</p>
<pre class="prettyprint lang-sarl linenums">class SchedulesSkill extends Skill implements Schedules {

  def task(name : String) : AgentTask {
    var theTask = new Task
    theTask.name = name ?: UUID.randomUUID.toString
    return theTask
  }

}</pre>
<h5 id="Scheduling_an_agent_task">7.5.3. Scheduling an agent task</h5>
<p>The first function, named <code>in</code>, for scheduling an agent task permits to run the given task after a given delay.</p>
<p>If the task agent us <code>null</code>, the <code>in</code> function creates an agent task instance with an unique name.</p>
<p>The <code>in</code> function computes the time at which the task should be run. This computation is based on a call to the <code>getSimulationTime</code> function, which is providing the current time in the tinyMAS platform. This current time is increased with the delay given as parameter of the <code>in</code> function for obtaining the task's execution time.</p>
<p>After associated the task to the procedure given as parameter, the <code>in</code> function schedule the task by calling the <code>scheduleTask</code> function.</p>
<p>The <code>scheduleTask</code> function takes two parameters: the time at which the task must start, and the task to execute. This function updates the collection of the tasks to execute, which is stored and accessible with the <code>tasks</code> field. The <code>tasks</code> field contains a map from the task starting time to the collection of tasks to be started at this time.</p>
<pre class="prettyprint lang-sarl linenums">def in(task : AgentTask = null, delay : long, procedure : (io.sarl.lang.core.Agent) =&gt; void) : AgentTask {
  var theTask = task
  if (theTask === null) {
    theTask = new Task
    theTask.name = UUID.randomUUID.toString
  }
  var time = (owner as TMSarlAgent).getSimulationTime(TimeUnit::MILLISECONDS) as long + delay
  theTask.procedure = procedure
  scheduleTask(time, theTask)
  return theTask
}

val tasks : Map&lt;Long, Collection&lt;AgentTask&gt;&gt; = new TreeMap

private def scheduleTask(at : long, task : AgentTask) {
  var list = this.tasks.get(at)
  if (list === null) {
    list = new ArrayList
    this.tasks.put(at, list)
  }
  list += task
}</pre>
<h5 id="Executed_an_agent_task_once">7.5.4. Executed an agent task once</h5>
<p>It is possible to execute a task only one time by calling the <code>execute</code> function. In the tinyMAs implementation, the <code>execute</code> function schedule the task for the next simulation step.</p>
<pre class="prettyprint lang-sarl linenums">def execute(task : AgentTask = null, procedure : (io.sarl.lang.core.Agent) =&gt; void) : AgentTask {
  return in(
    task,
    (owner as TMSarlAgent).getSimulationStepDuration(TimeUnit::MILLISECONDS) as long,
    procedure)
}</pre>
<h5 id="Scheduling_a_periodic_agent_task">7.5.5. Scheduling a periodic agent task</h5>
<p>It is possible to schedule periodic tasks by calling the <code>every</code> function. The definition of this function is similar to the definition of the <code>in</code> function, except that the <code>period</code> field of the <code>Task</code> is set with the period duration, which is given as parameter.</p>
<p>The <code>atFixedDelay</code> function delegates to the <code>every</code> function because the task running algorithm implies that these two types of execution approach will be the same on tinyMAS.</p>
<pre class="prettyprint lang-sarl linenums">def every(task : AgentTask = null, period : long, procedure : (io.sarl.lang.core.Agent) =&gt; void) : AgentTask {
  var theTask = task
  if (theTask === null) {
    theTask = new Task
    theTask.name = UUID.randomUUID.toString
  }
  var time = (owner as TMSarlAgent).getSimulationTime(TimeUnit::MILLISECONDS) as long + period
  theTask.procedure = procedure
  if (theTask instanceof Task) {
    theTask.period = period
  }
  scheduleTask(time, theTask)
  return theTask
}

def atFixedDelay(task : AgentTask = null, delay : long, procedure : (io.sarl.lang.core.Agent) =&gt; void) : AgentTask {
  return task.every(delay, procedure)
}</pre>
<h5 id="Canceling_an_agent_task">7.5.6. Canceling an agent task</h5>
<p>The <code>Schedules</code> capacity provides the feature for canceling a task by calling the <code>cancel</code> function. This function delegates to the <code>cancel</code> function of the <code>Task</code> type.</p>
<pre class="prettyprint lang-sarl linenums">def cancel(task : AgentTask, mayInterruptIfRunning : boolean = true) : boolean {
  if (task instanceof Task) {
    task.cancel
    return true
  }
  return false
}</pre>
<h5 id="Running_the_scheduled_tasks">7.5.7. Running the scheduled tasks</h5>
<p>Executing the registered tasks must be supported by a specific function, named <code>runTasks</code>.</p>
<p>This function determines the current time (<code>currentTime</code>) in the tinyMAS platform. Then, it retrieves the <code>list</code> of the tasks to start at the current time.</p>
<p>&lt;p&lt;For each task in the <code>list</code>, the function tests if the task was cancelled or not. If the task was not cancelled, the function retrieves the task's guard (the condition of execution) and evaluates it.</p>
<p>If the task's guard is evaluated to <code>true</code>, the function executes the procedure associated to the task.</p>
<p>Finally, the <code>runTasks</code> function reschedules the task is its periodic execution period is greater than zero.</p>
<pre class="prettyprint lang-sarl linenums">def runTasks {
  var currentTime = (owner as TMSarlAgent).getSimulationTime(TimeUnit::MILLISECONDS) as long
  var list = this.tasks.remove(currentTime)
  if (list !== null) {
    for (task : list) {
      var canceled = false
      if (task instanceof Task) {
        canceled = task.canceled
      }
      if (!canceled) {
        var guard = task.guard
        if (guard === null || guard.apply((owner as TMSarlAgent).sarlAgent)) {
          var code = task.procedure
          if (code !== null) {
            code.apply((owner as TMSarlAgent).sarlAgent)
          }
          if (task instanceof Task) {
            if (task.period &gt; 0) {
              scheduleTask(currentTime + task.period, task)
            }
          }
        }
      }
    }
  }
}</pre>
<h5 id="Updating_the_tinyMAS_agent_living_function">7.5.8. Updating the tinyMAS agent living function</h5>
<p>Now the <code>runTasks</code> function is defined in the <code>SchedulesSkill</code> class, we could update the tinyMAS agent life-cycle in order to invoke this function.</p>
<p>The agent tasks must be run at each step of the tinyMAS agent life. Consequently, we must redefine the <code>live</code> function in the <code>TMSarlAgent</code> class for invoking <code>runTasks</code>.</p>
<p>In order to call the <code>runTasks</code> function, we must assume that the <code>schedulesSkill</code> field is defined as a reference to the instance of <code>SchedulesSkill</code> built-in capacity. How this field is set will be described in a further section.</p>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends Agent implements EventListener {

  // [...]

  var schedulesSkill : SchedulesSkill

  def live {
    for (beh : this.behaviorsSkill.registrationWaiters) {
      this.evaluatorRegistry.register(beh)
    }
    for (beh : this.behaviorsSkill.unregistrationWaiters) {
      this.evaluatorRegistry.unregister(beh)
    }
    this.schedulesSkill.runTasks
  }

}</pre>
<h4 id="Definition_of_the_Time_skill">7.6. Definition of the Time skill</h4>
<p>The definition of the <code>Time</code> built-in capacity is based on the delegation to the tinyMAS time manager that is accessible from the agent owning the capacity.</p>
<pre class="prettyprint lang-sarl linenums">class TimeSkill extends Skill implements Time {

  def getTime(timeUnit : TimeUnit = null) : double {
    (owner as TMSarlAgent).getSimulationTime(timeUnit ?: TimeUnit::SECONDS)
  }

  def getOSTimeFactor : double {
    (owner as TMSarlAgent).getSimulationStepDuration(TimeUnit::SECONDS)
  }

}</pre>
<h4 id="Definition_of_the_ExternalContextAccess_and_InnerContextAccess_skills">7.7. Definition of the ExternalContextAccess and InnerContextAccess skills</h4>
<p>Because of a design choice, we have decided to no provide the implementation of the built-in capacities <code>ExternalContextAccess</code> and <code>InnerContextAccess</code>.</p>
<h4 id="Creating_built_in_capacity_instances_in_the_agent">7.8. Creating built-in capacity instances in the agent</h4>
<p>Once the built-in capacity are implemented for the tinyMAS platform, we must implement the built-in capacities' instantiation and release.</p>
<h5 id="Storing_the_built_in_capacities_in_agent_fields">7.8.1. Storing the built-in capacities in agent fields</h5>
<p>Because the built-in capacities' instances exist during the whole life of the associated agent, these instances must be stored in agent's fields.</p>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends Agent implements EventListener {

  // [...]

  var behaviorSkill : BehaviorsSkill
  var loggingSkill : LoggingSkill
  var spaceSkill : DefaultContextInteractionsSkill
  var lifeSkill : LifecycleSkill
  var scheduleSkill : SchedulesSkill
  var timeSkill : TimeSkill

}</pre>
<h5 id="Initializing_the_agent_built_in_capacities">7.8.2. Initializing the agent built-in capacities</h5>
<p>For initializing the agent's built-in capacities, the <code>start</code> function of the <code>TMSarlAgent</code> type must be updated for: </p>
<ul> <li>creating the built-in capacities' instances; and </li> <li>calling the <code>setSkill</code> function on the SARL agent for setting the capacities.</li> <ul>
<p>Calling the <code>setSkill</code> function implies the call to the <code>install</code> function of the skill.</p>
<p>The calls to the <code>setSkill</code> function are done by using Java reflection because the <code>setSkill</code> function is a protected function in the SARL agent type. Retrieving the method by reflection, and enabling the accessibility, allows to ignore the <code>protected</code> modifier of the <code>setSkill</code> function.</p>
</ul>
</ul>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends Agent implements EventListener {

  // [...]

  def start {
    super.start
    this.evaluatorRegistry.register(sarlAgent)

    this.behaviorSkill = new BehaviorsSkill
    this.loggingSkill = new LoggingSkill
    this.spaceSkill = new DefaultContextInteractionsSkill
    this.lifeSkill = new LifecycleSkill
    this.scheduleSkill = new SchedulesSkill
    this.timeSkill = new TimeSkill

    var method = typeof(io.sarl.lang.core.Agent).getDeclaredMethod("setSkill", typeof(Class), typeof(Skill))
    method.accessible = true
    method.invoke(sarlAgent, typeof(Behaviors), this.behaviorSkill)
    method.invoke(sarlAgent, typeof(Logging), this.loggingSkill)
    method.invoke(sarlAgent, typeof(DefaultContextInteractions), this.spaceSkill)
    method.invoke(sarlAgent, typeof(Lifecycle), this.lifeSkill)
    method.invoke(sarlAgent, typeof(Schedules), this.scheduleSkill)
    method.invoke(sarlAgent, typeof(Time), this.timeSkill)

    var initializeEvent = new Initialize(this.spawnerID, this.parameters)
    this.spawnerID = null
    this.parameters = null
    receiveEvent(initializeEvent)
  }

}</pre>
<h5 id="Uninstalling_the_agent_built_in_capacities">7.8.3. Uninstalling the agent built-in capacities</h5>
<p>For uninstalling the agent's built-in capacities, the <code>stop</code> function of the <code>TMSarlAgent</code> type must be updated for calling the <code>clearSkill</code> function on the SARL agent for uninstalling the capacities.</p>
<p>Calling the <code>clearSkill</code> function implies the call to the <code>uninstall</code> function of the skill.</p>
<p>The calls to the <code>clearSkill</code> function are done by using Java reflection because the <code>clearSkill</code> function is a protected function in the SARL agent type. Retrieving the method by reflection, and enabling the accessibility, allows to ignore the <code>protected</code> modifier of the <code>clearSkill</code> function.</p>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends Agent implements EventListener {

  // [...]

  def stop {
    receiveEvent(new Destroy)

    var method = typeof(io.sarl.lang.core.Agent).getDeclaredMethod("clearSkill", typeof(Class))
    method.accessible = true
    method.invoke(sarlAgent, typeof(Time))
    method.invoke(sarlAgent, typeof(Schedules))
    method.invoke(sarlAgent, typeof(Lifecycle))
    method.invoke(sarlAgent, typeof(DefaultContextInteractions))
    method.invoke(sarlAgent, typeof(Logging))
    method.invoke(sarlAgent, typeof(Behaviors))

    this.evaluatorRegistry.unregister(sarlAgent)
    super.stop
  }

}</pre>
<h3 id="From_the_tinyMAS_proactive_message_ready_to_the_SARL_reactive_event_handling">8. From the tinyMAS proactive message ready to the SARL reactive event handling</h3>
<p>In the tinyMAs platform, agents are proactive for reading the messages they have received: the agents call explicitely the functions for reading the messages. In SARL, the agents are reactive regarding the event handling: the agents are automatically notified when they received events.</p>
<p>It is mandatory to redefine the agent living function <code>live</code> for mapping the proactive behavior of the tinyMAS agents to the reactive behavior of the SARL agents.</p>
<p>The <code>live</code> function loops on the content of the mailbox (<code>while hasMessage</code>). For each message, the function gets its content, and if it is a SARL event, the <code>live</code> function fires the event by calling the <code>receiveEvent</code> function.</p>
<pre class="prettyprint lang-sarl linenums">class TMSarlAgent extends Agent implements EventListener {

  // [...]

  def live {
    for (beh : this.behaviorsSkill.registrationWaiters) {
      this.evaluatorRegistry.register(beh)
    }
    for (beh : this.behaviorsSkill.unregistrationWaiters) {
      this.evaluatorRegistry.unregister(beh)
    }

    while (hasMessage) {
      var message = nextMessage
      var content = message.content
      if (content instanceof Event) {
        receiveEvent(content)
      }
    }

    this.schedulesSkill.runTasks
  }

}</pre>
<h3 id="Booting_infrastructure">9. Booting infrastructure</h3>
<p>The next step for making tinyMAS a simple SARL run-time environment (SRE) is to define the utility class for booting tinyMAS as a SRE. We define the <code>Boot</code> class for supporting the tinyMAS kernel booting.</p>
<p>As for the <a href="http://www.janusproject.io">standard SRE Janus</a>, we assume that the main entry point of the SRE expects the fully qualified name of the agent to launch as the first command-line argument. the rest of the command-line arguments will be given as initialization arguments to the launched agent.</p>
<h4 id="Definition_of_the_main_entry_point">9.1. Definition of the main entry point</h4>
<p>We define the <code>Boot</code> class with a main function as the SRE entry point. It extends the <code>Kernel</code> class provided by the tinyMAS platform for representing its kernel.</p>
<pre class="prettyprint lang-sarl linenums">class Boot extends Kernel {

  def static main(args : String[]) {
  }

}</pre>
<h4 id="Creation_of_the_SARL_default_context_and_space_instances">9.2. Creation of the SARL default context and space instances</h4>
<p>For creating an instance of the tinyMAS platform, three components must be created: </p>
<ul> <li>
<code>whitePages</code> for storing the running agents in the tinyMAS kernel;</li> <li>
<code>yellowPages</code> as the repository of the services provided by the tinyMAS agents; and</li> <li>
<code>mts</code> as the kernel service for routing the messages from a tinyMAS agent to another.</li> </ul>
<p>The three tinyMAS components are defined and used for initializing: </p>
<ul> <li>the SARL default space, named <code>defaultSpace</code>,</li> <li>the SARL default context, named <code>context</code>, and </li> <li>the tinyMAS kernel instance, named <code>kernel</code>.</li> <p>The reference from the default space to the containing context must be manually set by invoking: <code>
defaultSpace.agentContext = context
</code></p>
<p>The <code>Boot</code> instance contains the default space as field, named <code>defaultSpace</code>. In the constructor of the <code>Boot</code> class, the tinyMAS kernel identifier is given to the default space. Indeed, the tinyMAS kernel identifier is known only when the tinyMAS kernel instance is created.</p>
</ul>
<pre class="prettyprint lang-sarl linenums">class Boot extends Kernel {

  def static main(args : String[]) {
    var whitePages = new WhitePages
    var yellowPages = new YellowPages
    var mts = new MessageTransportService

    var defaultSpace = new TMDefaultSpace(whitePages, mts)

    var kernel = new Boot(defaultSpace, mts, whitePages, yellowPages)
    
    var context = new TMAgentContext(defaultSpace)
    defaultSpace.agentContext = context
  }

  val defaultSpace : TMDefaultSpace

  new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
      whitePages : WhitePages, yellowPages : YellowPages) {
    super(mts, whitePages, yellowPages)
    this.defaultSpace = defaultSpace
    this.defaultSpace.kernelID = kernelId
  }

}</pre>
<h4 id="Management_of_the_command_line_parameters">9.3. Management of the command-line parameters</h4>
<p>The main entry point must parse the command-line arguments for extracting the fully qualified name of the agent to launch (named <code>agentType</code>), and the agent initialization parameters, named <code>params</code>.</p>
<pre class="prettyprint lang-sarl linenums">class Boot extends Kernel {

  def static main(args : String[]) {
    var whitePages = new WhitePages
    var yellowPages = new YellowPages
    var mts = new MessageTransportService

    var defaultSpace = new TMDefaultSpace(whitePages, mts)

    var kernel = new Boot(defaultSpace, mts, whitePages, yellowPages)
    
    var context = new TMAgentContext(defaultSpace)
    defaultSpace.agentContext = context
    
    val agentName = args.get(0)
    var agentType = Class::forName(agentName)
    var params = Array.newInstance(typeof(Object), args.size - 1) as Object[]
    for (var i = 0; i &lt; params.length; i++) {
      params.set(i, args.get(i + 1))
    }
  }

  val defaultSpace : TMDefaultSpace

  new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
      whitePages : WhitePages, yellowPages : YellowPages) {
    super(mts, whitePages, yellowPages)
    this.defaultSpace = defaultSpace
    this.defaultSpace.kernelID = kernelId
  }

}</pre>
<h4 id="Launching">9.4. Launching</h4>
<p>The launching process starts an agent by invoked the function <code>spawn</code> of the utility class <code>Spawner</code>.</p>
<p>The <code>spawn</code> function adds the agent into the registry of the agents, but it does not run the tinyMAS platform. For running the tinyMAS platform, the <code>run</code> function of the tinyMAS <code>Kernel</code> must be invoked.</p>
<pre class="prettyprint lang-sarl linenums">class Boot extends Kernel {

  def static main(args : String[]) {
    var whitePages = new WhitePages
    var yellowPages = new YellowPages
    var mts = new MessageTransportService

    var defaultSpace = new TMDefaultSpace(whitePages, mts)

    var kernel = new Boot(defaultSpace, mts, whitePages, yellowPages)
    
    var context = new TMAgentContext(defaultSpace)
    defaultSpace.agentContext = context
    
    val agentName = args.get(0)
    var agentType = Class::forName(agentName)
    var params = Array.newInstance(typeof(Object), args.size - 1) as Object[]
    for (var i = 0; i &lt; params.length; i++) {
      params.set(i, args.get(i + 1))
    }

    if (typeof(io.sarl.lang.core.Agent).isAssignableFrom(agentType)) {
      Spawner.spawn(
        kernel,
        defaultSpace,
        agentType as Class&lt;? extends io.sarl.lang.core.Agent&gt;,
        null,
        TMDefaultSpace.TINYMAS_DEFAULT_SPACE_ID,
        null,
        params)
    }

    kernel.run
  }

  val defaultSpace : TMDefaultSpace

  new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
      whitePages : WhitePages, yellowPages : YellowPages) {
    super(mts, whitePages, yellowPages)
    this.defaultSpace = defaultSpace
    this.defaultSpace.kernelID = kernelId
  }

}</pre>
<h3 id="General_Events">10. General Events</h3>
<p>According to the SARL specification, a SARL run-time environment should fire specific platform-level events: </p>
<ul> <li>
<code>AgentSpawned</code> should be fired in the default space when an agent is created;</li> <li>
<code>AgentKilled</code> should be fired in the default space when an agent is killed;</li> <li>
<code>ContextJoined</code> should be fired in the agent when it has joint a context;</li> <li>
<code>ContextLeft</code> should be fired in the agent when it has left a context;</li> <li>
<code>MemberJoined</code> should be fired in the default space when an agent has joint a context;</li> <li>
<code>MemberLeft</code> should be fired in the default space when an agent has left a context.</li> </ul>
<p>According to the design choice of supporting only one context and one interaction space, only the <code>AgentSpawned</code> and <code>AgentKilled</code> must be really supported by the tinyMAS platform.</p>
<p>According to the tinyMAS specification, the only one way to determine when an agent is created or killed is to register a specific event listener on the tinyMAS kernel. Since this specific listener must exist during the entire life of the kernel, we register the listener at the creation of the <code>Boot</code> class.</p>
<p>Even for <code>AgentSpawned</code> and <code>AgentKilled</code>, the event firing follows the same steps: </p>
<ul> <li>The source of the event is the tinyMAS platform, represented by the address with the default context identifier.</li> <li>The created/destroyed agent's type is the type of the SARL agent or <code>null</code>.</li> <li>The event is built from the computed information and the agent identifier given as parameter.</li> <li>The event is fired in the default space.</li> </ul>
<pre class="prettyprint lang-sarl linenums">class Boot extends Kernel {

  static class TinyMASKernelListener extends KernelAdapter {

    val containingBoot : Boot

    new(containingBoot : Boot) {
      this.containingBoot = containingBoot
    }

    def kernelAgentAdded(kernel : Kernel, ^agent : Agent, id : AgentIdentifier) {
      var source = new Address(
          containingBoot.defaultSpace.spaceID,
          TMDefaultSpace::TINYMAS_DEFAULT_SPACE_ID)
      var agentType : String
      if (^agent instanceof TMSarlAgent) {
        agentType = ^agent.sarlAgent.class.name
      } else {
        agentType = null
      }
      var spawnEvent = new AgentSpawned(source,
          Identifiers::toUUID(id),
          agentType)
      containingBoot.defaultSpace.emit(spawnEvent)
    }

    def kernelAgentRemoved(kernel : Kernel, ^agent : Agent, id : AgentIdentifier) {
      var source = new Address(
          containingBoot.defaultSpace.spaceID,
          TMDefaultSpace::TINYMAS_DEFAULT_SPACE_ID)
      var agentType : String
      if (^agent instanceof TMSarlAgent) {
        agentType = ^agent.sarlAgent.class.name
      } else {
        agentType = null
      }
      var spawnEvent = new AgentKilled(source,
          Identifiers::toUUID(id),
          agentType)
      containingBoot.defaultSpace.emit(spawnEvent)
    }

  }

  new (defaultSpace : TMDefaultSpace, mts : MessageTransportService,
      whitePages : WhitePages, yellowPages : YellowPages) {
    super(mts, whitePages, yellowPages)
    this.defaultSpace = defaultSpace
    this.defaultSpace.kernelID = kernelId

    addKernelListener(new TinyMASKernelListener(this))
  }

}</pre>
<h3 id="Finalizing_the_agent_spawning">11. Finalizing the agent spawning</h3>
<p>The agent spawning function defined in the <code>TMDefaultSpace</code> type assumes the created agents are buffered until their real addition into the tinyMAS platform. Until this point of the document, we have not implemented the addition of the buffered agents into the tinyMAS kernel.</p>
<p>According to the tinyMAS specification, the agents should be added at the end of each step of the tinyMAS kernel. It is not possible to override a function for added a code at the end of the tinyMAS kernel loop. Fortunately, each tinyMAs event listener is notified when the tinyMAs kernel has finished its internal execution loop: the <code>kernelRefreshAllowed</code> function of the <code>KernelListener</code> (or its <code>KernelAdapter</code> implementation) is called.</p>
<p>We update the <code>TinyMASKernelListener</code> inner class, which is defined in the previous section by adding the definition of the <code>kernelRefreshAllowed</code> function.</p>
<p>The <code>kernelRefreshAllowed</code> function retrieves the buffered agents from the default space, by invoking the <code>consumeAgentToLaunch</code> function. Each agent replied by the <code>consumeAgentToLaunch</code> function is spawned in the tinyMAS platform by calling the <code>Spawner</code> utility class.</p>
<pre class="prettyprint lang-sarl linenums">def kernelRefreshAllowed(kernel : Kernel) {
  for (^agent : containingBoot.defaultSpace.consumeAgentToLaunch) {
    Spawner.spawn(kernel, ^agent)
  }
}</pre>
<h3 id="Update_of_the_Jar_Manifest_for_making_the_archive_as_a_SRE">12. Update of the Jar Manifest for making the archive as a SRE</h3>
<p>Now, the code for making a SARL run-time environment (SRE) with the tinyMAS platform is ready. For enabling the tinyMAS platform to be recognized as a SRE by the Eclipse SARL development environment, the manifest file of the Jar archive of tinyMAs must contains mandatory information that are explained in this section.</p>
<h4 id="Definition_of_the_configuration_elements">12.1. Definition of the configuration elements</h4>
<p>The configuration elements for defining a SRE are:</p>
<table class="table-bordered">
<thead>
<tr>
<th>Name</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main-Class</td>
		<td>The fully qualified name of the main class of the program, usually the `Boot` class that is
			previously defined.</td>
</tr>
<tr>
<td>SARL-Spec-Version</td>
		<td>The version number of the SARL specification from which this SRE was created.</td>
</tr>
<tr>
<td>SRE-Name</td>
		<td>The name of the SRE.</td>
</tr>
<tr>
<td>VM-Arguments</td>
		<td>The arguments to pass to the Java virtual machine that will run the SRE.</td>
</tr>
<tr>
<td>Program-Arguments</td>
		<td>The arguments to pass to the application, i.e. the launched agent.</td>
</tr>
<tr>
<td>Standalone-SRE</td>
		<td>Indicates if the SRE's archive contains all the classes that are needed for running
			the SRE (if the value of Standalone-SRE is <code>true</code>), or if the SRE's
			archive contains only the SRE classes and not the dependency classes (if the value
			of Standalone-SRE is <code>false</code>).</td>
</tr>
<tr>
<td>CLI-Show-Logo</td>
		<td>The command-line option to pass to the SRE for displaying the SRE logo at startup.</td>
</tr>
<tr>
<td>CLI-Hide-Logo</td>
		<td>The command-line option to pass to the SRE for hiding the SRE logo at startup.</td>
</tr>
<tr>
<td>CLI-Show-Info</td>
		<td>The command-line option to pass to the SRE for enabling information logging.</td>
</tr>
<tr>
<td>CLI-Hide-Info</td>
		<td>The command-line option to pass to the SRE for disabling information logging.</td>
</tr>
<tr>
<td>CLI-Default-Context-ID</td>
		<td>The command-line option to pass to the SRE for using the default context identifier.</td>
</tr>
<tr>
<td>CLI-Random-Context-ID</td>
		<td>The command-line option to pass to the SRE for computing a random value for the default context identifier.</td>
</tr>
<tr>
<td>CLI-BootAgent-Context-ID</td>
		<td>The command-line option to pass to the SRE for computing a value from the boot agent classname for the default context identifier.</td>
</tr>
<tr>
<td>CLI-Offline</td>
		<td>The command-line option to pass to the SRE for disabling the network support (network is assumed to be on by default).</td>
</tr>
<tr>
<td>CLI-No-More-Option</td>
		<td>The command-line option to pass to the SRE for indicating that the rest of the command-line arguments could not be command-line optoins (usually <code>--</code>).</td>
</tr>
<tr>
<td>CLI-Embedded</td>
		<td>The command-line option to pass to the SRE for indicating to the SRE it is running inside the process of the Eclipse SARL development environment.</td>
</tr>
</tbody>
</table>
<h4 id="How_to_update_the_Jar_Manifest_by_hand">12.2. How to update the Jar Manifest by hand</h4>
<p>The previously defined configuration elements must appear inside the manifest file of the Jar archive of the tinyMAS platform.</p>
<p>The <code>Main-Class</code> entry must appear in the main section of the manifest. For example, the <code>Boot</code> class that is defined in the previous sections of this document is the main class of the tinyMAS SRE. It must be specified in the manifest file as:</p>
<p><code>
Main-Class: org.arakhne.tinymas.sarl.Boot
</code></p>
<p>The other configuration elements from the previous section must be specified in the manifest file in a specific section, named <code>SARL-Runtime-Environment</code>.</p>
<p>The following manifest context gives an example of the tinyMAS SRE declaration: ``` Main-Class: org.arakhne.tinymas.sarl.Boot</p>
<p>SARL-Runtime-Environment: SRE-Name: TinyMAS SARL-Spec-Version: 0.5 Standalone-SRE : true VM-Arguments: -ea Program-Arguments: CLI-Show-Logo: CLI-Hide-Logo: CLI-Show-Info: CLI-Hide-Info: CLI-Default-Context-ID: CLI-Random-Context-ID: CLI-BootAgent-Context-ID: CLI-Offline: CLI-Embedded: CLI-No-More-Option: ```</p>
<h4 id="Maven_Plugin_for_Updating_the_Manifest">12.3. Maven Plugin for Updating the Manifest</h4>
<p>The SARL project provides a <a href="http://maven.apache.org">Maven</a> plugin that enables the SRE developer to update the manifest file automatically when the SRE project is built/compile (with Maven).</p>
<p>The Maven plugin is: </p>
<ul> <li>GroupID: <code>io.sarl.maven</code>
</li> <li>ArtifactID: <code>io.sarl.maven.sre</code>
</li> </ul>
<p>The mojo action defined by the SRE Maven plugin is <code>updatemanifest</code>. This mojo action updates the existing manifest file with the SRE information.</p>
<p>The following XML code gives an example of Maven configuration that enables to use the SRE Maven plugin.</p>
<pre class="prettyprint">
&lt;build&gt;
	&lt;plugins&gt;
		&lt;plugin&gt;
			&lt;groupId&gt;io.sarl.maven&lt;/groupId&gt;
			&lt;artifactId&gt;io.sarl.maven.sre&lt;/artifactId&gt;
			&lt;version&gt;${sarl.version}&lt;/version&gt;
			&lt;configuration&gt;
				&lt;sreName&gt;TinyMAS&lt;/sreName&gt;
				&lt;commandLineOptions&gt;
					&lt;hideInfo&gt;&lt;/hideInfo&gt;
					&lt;hideLogo&gt;&lt;/hideLogo&gt;
					&lt;showInfo&gt;&lt;/showInfo&gt;
					&lt;showLogo&gt;&lt;/showLogo&gt;
					&lt;defaultContextId&gt;&lt;/defaultContextId&gt;
					&lt;randomContextId&gt;&lt;/randomContextId&gt;
					&lt;bootAgentContextId&gt;&lt;/bootAgentContextId&gt;
					&lt;offline&gt;&lt;/offline&gt;
					&lt;embedded&gt;&lt;/embedded&gt;
					&lt;noMoreOption&gt;&lt;/noMoreOption&gt;
					&lt;standaloneSRE&gt;true&lt;/standaloneSRE&gt;
				&lt;/commandLineOptions&gt;
				&lt;mainClass&gt;${cliRunnerMainClass}&lt;/mainClass&gt;
			&lt;/configuration&gt;

			&lt;executions&gt;
				&lt;execution&gt;
					&lt;id&gt;update-manifest-standard&lt;/id&gt;
					&lt;goals&gt;
						&lt;goal&gt;updatemanifest&lt;/goal&gt;
					&lt;/goals&gt;
				&lt;/execution&gt;
			&lt;/executions&gt;
		&lt;/plugin&gt;
	&lt;/plugins&gt;
&lt;/build&gt;
</pre>
<h3 id="Legal_Notice">13. Legal Notice</h3>
<p>Specification: SARL General-purpose Agent-Oriented Programming Language ("Specification")<br> Version: 0.5<br> Status: Stable Release<br> Release: 2017-03-18</p>
<p>Copyright © 2014-2017 the original authors or authors.</p>
<p>Licensed under the Apache License, Version 2.0; you may not use this file except in compliance with the License. You may obtain a copy of the <a href="http://www.apache.org/licenses/LICENSE-2.0">License</a>.</p>
							</div>
<hr/><p><small>The SARL Documentation is generated with <a href='http://www.jnario.org' target='_blank'>Jnario</a></small></p>
    </div> <!-- /default layout container -->

    <div class="container">
  <!-- FOOTER -->
  <footer>
    <div class="row">
      
    <div class="col-lg-3">
    <div class="well well-sm">
      
      <center>
      <h2>SARL</h2>
      <div>Agent-Oriented Programming Language</div>
      <img src="../../../../../../images/SARL-logo.png" style="width:30%;max-width:64px;"/><br/>
      <small><a href="../../../../../../images/SARL-logo.png">png</a>&nbsp;&middot;&nbsp;<a href="../../../../../../images/SARL-logo.svg">svg</a></small>
      </center>
    </div>
    </div>
    <div class="col-lg-3">
      <div class="well well-sm">
      <h2><i class="glyphicon glyphicon-th-large"></i> Quick Links </h2> 
      <ul>
        <li><a href="../../../../../../news/index.html">SARL News</a></li>
        <li><a href="../../../../../../about/index.html">About SARL</a></li>
        <li><a href="../../../../../../about/index.html">License</a></li>
      </ul>
      </div> 
    </div>
    <div class="col-lg-3">
      <div class="well well-sm">
      <h2><i class="glyphicon glyphicon-cog"></i> Support</h2>
      <ul>
        <li><a href="../../../../../../community/forums.html">User Forums</a></li>
        <li><a href="https://www.facebook.com/sarllanguage">On Facebook</a></li>
        <li><a href="http://github.com/sarl/sarl">View on Github</a></li>
        <li><a href="http://github.com/sarl/sarl/issues">Report an Issue</a></li>
      </ul>
      </div> 
    </div>
    <div class="col-lg-3">
      <div class="well well-sm">
      <h2><i class="glyphicon glyphicon-link"></i> Links</h2>
      <ul>
        <li><a href="http://www.janusproject.io">Janus Project</a></li>
        <li><a href="http://www.gitia.org">GITIA - FRT - UTN</a></li>
        <li><a href="http://www.multiagent.fr">MAS Group - LE2I - UBFC</a></li>
      </ul>
      </div> 
    </div>
    </div>
    
  </footer>
</div>


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../../../../../js/jquery.min.js"></script>
    <script src="../../../../../../js/bootstrap.min.js"></script>
    <script src="../../../../../../js/run_prettify.js"></script>
	<script src="../../../../../../js/lang-jnario.js"></script>
	<script src="../../../../../../js/lang-sarl.js"></script>
  </body>
</html>
